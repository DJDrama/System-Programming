[고급 파일 입출력(Advanced File I/O)]

(리눅스의 고급 입출력 시스템 콜(Advanced I/O System Calls))
- 벡터 입출력(Scatter/gather I/O): 한번의 호출로 여러 버퍼에서 데이터를 읽거나 쓸 수 있음(다양한 자료구조를 단일 I/O 트랜젝션으로 다룰 때 유용).
- epoll: Single Thread에서 수백 개의 fd를 poll 해야 하는 경우에 유용.
- 메모리맵 입출력(Memory-mapped I/O): 파일을 메모리에 맵핑해서 간단한 메모리 조작을 통해 파일 IO 수행(특정 패턴의 I/O에 유용).
- 파일 활용법 조언(File advice):프로세스에서 파일을 사용하려는 의도를 커널에게 제공할 수 있도록 하여, I/O 성능 향상.
- 비동기식 입출력(Asynchronous I/O): 스레들르 사용하지 않고, 동시에 입출력 부하가 많은 작업을 처리할 경우 유용.


1) 벡터 입출력(Scatter/Gather I/O)
	- 한번의 시스템 콜로 여러 개의 버퍼 벡터에 쓰거나 여러 개의 버퍼 벡터로 읽어 들일 때 사용하는 I/O 메서드.
	- scattered into(여러 버퍼 멕터로 흩뿌리거나), gathred from(여러 버퍼 벡터로부터 모으기)
		* Standard read and write 시스템 콜은 선형 I/O(Linear I/O)

	
	(선형 입출력에 비해 갖는 장점)
		
		> 더 자연스러운 코딩 패턴(More natural coding pattern)
			$ If data is naturally segmented(데이터가 자연스럽게 분리되어 있다면), 미리 정의된 구조체의 여러 필드에 걸쳐 데이터가 분리되어 있는 경우 벡터 입출력을 사용하면 직관적인 방법으로 조작 가능.
		
		> 효율(Efficiency)
			$ 여러 번의 선형 입출력 연산을 대체 할 수 있음.
		
		> 성능(Performance)
			$ 시스템 콜의 호출 횟수를 줄여줌.
			$ 여러 번의 선형 입출력 연산을 대체 할 수 있음.

		> 원자성(Atomicity)
			$ 벡터 입출력 연산 중에 다른 프로세스가 끼어들 여지가 없음(여러 번의 선형 입출력 연산과는 대조적).

	- readv()와 writev()
		> 벡터 입출력 시스템 콜
			$ readv()
				========================================================================
				#include <sys/uio.h>

				// fd에서 데이터를 읽어서 count 개수(count segments)만큼의 iov 버퍼에 저장.
				ssize_t readv(int fd, const struct iovec *iov, int count);
				========================================================================
				# 각 버퍼에 (iovec 구조체의)iov_len 바이트 만큼 채운 후 다음 버퍼를 채운다.

			$ writev()
				========================================================================
				#include <sys/uio.h>

				// count 개수만큼의 iov 버퍼에 있는 데이터를 fd에 기록.
				ssize_t writev(int fd, const struct iovec *iov, int count);
				========================================================================
				# (iovec 구조체의)iov_len 바이트만큼의 데이터를 모두 쓴 다음에 다음 버퍼의 내용을 기록한다.

		* read(), write()와 동일하게 동작하지만, 여러 개의 버퍼를 사용한다는 점에서 구분됨.

			$ iovec 구조체 (세그먼트라고 하는 독립적으로 분리된 버퍼)
				========================================================================
				#include <sys/uio.h>

				struct iovec {
					void *iov_base; /* 버퍼의 시작 포인터 */
					size_t iov_len; /* 버퍼 크기(바이트) */
				}
				========================================================================

				$ 벡터(vector): 이런 세그먼트의 집합
					# 벡터의 각 세그먼트에는 데이터를 기록하거나 읽어올 메모리 공간의 주소와 크기가 저장되어 있음.

		> 반환값
			$ 호출 성공: 읽거나 쓴 바이트 개수 반환(count*iov_len 값과 같아야 함)
			$ 에러: -1 반환, errno 설정
			$ read(), write() 시스템 콜에서 발생 가능한 모든 종류의 에러가 발생할 수 있으며 errno 설정.
				* 표준에서는 추가로 2가지의 에러 상황을 정의
					(1) count*iov_len 값이 SSIZE_MAX 값보다 큰 경우
						--> 데이터가 전송되지 않고 -1 반환
						--> errno는 EINVAL로 설정
					(2) count 값이 0보다 크고 <limits.h>에 정의된 IOV_MAX와 같거나 작아야 함.
						* 리눅스에서는 IOV_MAX=1024
						--> 만약 count가 0이면 readv(), writev()는 0을 반환
						--> 만약 count가 IOV_MAX보다 크면 데이터는 전송되지 않고 -1 반환, errno=EINVAL

		> 최적 count = 8
			$ 벡터 입출력 작업을 하는 동안 리눅스 커널에서는 각 세그먼트를 위한 내부 데이터 구조체를 반드시 할당함.
			$ count의 크기에 따라 동적으로 일어나지만, 최적화를 위해 리눅스 커널은 count 값이 크지 않을 경우 사용할 작은 세그먼트 배열을 스택에 
			  미리 만들어 둔다(세그먼트를 위한 동적 할당이 일어나지 않도록 하는 방법으로 성능 개선).
			$ 최적 값은 현재 8, 벡터 입출력 연산에 사용할 세그먼트 개수를 어느 정도로 할지 감이 오지 않을 때는 8이나 그보다 작은 크기로 먼저 
			  시도해보자.

		> 리눅스 커널 내부의 모든 입출력은 벡터 입출력이다.
			$ read(), write() 구현 역시 하나짜리 세그먼트를 가지는 벡터 입출력으로 구현되어 있다.

2) epoll
	- 리눅스 전용 시스템 콜.
	- poll(), select()는 실행할 때마다 전체 fd를 요구한다 --> fd의 크기가 클수록 모든 리스트를 다 검사해야하는 과정이 병목현상으로 작용.
	- epoll은 실제로 검사하는 부분과 검사할 fd를 등록하는 부분을 분리하여 병목현상 회피.
		========================================================================
		#include <sys/epoll.h>

		int epoll_create1(int flags);
		========================================================================
		> 호출 성공: 새로운 epoll 인스턴스 생성하고 연관된 파일 디스크립터를 반환.
		> flags: EPOLL_CLOSEXEC만 유효(새 프로세스가 실행될 때 이 파일을 자동적으로 닫아준다.)
		> 에러: -1 반환, errno 설정
			$ EINVAL:  잘못된 flags 인자
			$ EMFILE: 사용자가 열 수 있는 최대 파일 초과
			$ ENFILE: 시스템에서 열 수 있는 최대 파일 초과
			$ ENOMEM: 작업을 수행하기 위한 메모리가 부족

		* epoll_create1()에서 반환하는 fd는 폴링이 끝난 뒤 반드시 close() 시스템 콜로 닫아줘야 한다.

	- epoll 제어
		========================================================================
		#include <sys/epoll.h>

		int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
		========================================================================
		========================================================================
		struct epoll_event {
			__u32 events; /* events */
			union { // 멤버 변수끼리 메모리를 공유하는 것. (다른 멤버 변수에 값을 넣으면 기존의 값은 지워진다는 단점)
				void *ptr;
				int fd;
				__u32 u32;
				__u64 u64;
			} data;
		};
		========================================================================
		> 호출 성공: 해당 epoll 인스턴스는 epfd 파일 디스크립터와 연결된다. (0을 반환)
		> op: fd가 가리키는 파일에 대한 작업을 명시
			$ EPOLL_CTL_ADD: epfd와 연관된 epoll 인스턴스가 fd와 연관된 파일을 감시하도록 추가하며 각 이벤트는 event 인자로 정의.
			$ EPOLL_CTL_DEL: epfd와 연관된 epoll 인스턴스에 fd를 감시하지 않도록 삭제.
			$ EPOLL_CTL_MOD: 기존에 감시하고 있는 fd에 대한 이벤트를 event에 명시된 내용으로 갱신.
		> event: 그 작업의 동작에 대한 설명을 담고 있음.
		> epoll_event
			$ events: 주어진 fd에서 감시할 이벤트의 목록을 담고 있다.
				# EPOLLERR: 해당 파일에서 발생하는 에러 상황(따로 지정하지 않아도 항상 감시함)
				# EPOLLET: 파일을 감시할 때 에지 트리거를 사용(기본 동작은 레벨 트리거 방식)
				# EPOLLHUP: 파일에서 발생하는 행업(hangup)을 감시(따로 지정하지 않아도 항상 감시함)
				# EPOLLIN: 파일 읽기가 지연되지 않고 바로 가능한지 감시
				# EPOLLONESHOT: 이벤트 발생 후 파일을 한번 읽고 나면 더 이상 감시하지 않음. 다시 활성화하려면 EPOLL_CTL_MOD를 통해
								새로운 이벤트 값 설정해야 함.
				# EPOLLOUT: 파일 쓰기가 지연되지 않고 바로 가능한지 감시
				# EPOLLPRI: 즉시 읽어야 할 OOB* 데이터가 있는지 감시.
										(OOB: Out of Band: TCP에서 전송되는 데이터는 스트림 기반으로 전송측에서 보낸 순서대로 받게 되는데, 이 순서를 무시하고 보내는 메시지)
			$ data: 사용자 데이터를 위한 필드
				# 요청한 이벤트가 발생해서 사용자에게 반환될 때 이 필드에 담긴 내용은 함께 반환된다.
				(예: 이벤트가 발생했을 때 어떤 fd를 들여다 봐야 하는지 쉽게 확인하는 용도로 사용)
		> 에러: -1 반환, errno 설정
			$ EBADF: epfd가 유효한 epoll 인스턴스가 아니거나, fd가 유효한 fd가 아닐 경우
			$ EEXIST: op가 EPOLL_CTL_ADD인데 fd가 이미 epfd와 연결되어 있는 경우
			$ EINVAL: epfd가 epoll 인스턴스가 아니거나 epfd가 fd와 같을 경우, 또는 잘못된 op값 사용
			$ ENOENT: op가 EPOLL_CTL_MOD, 혹은 EPOLL_CTL_DEL인데 fd가 epfd와 연결되어 있지 않은 경우
			$ ENOMEM: 해당 요청을 처리하기에 메모리가 부족한 경우
			$ EPRM: fd가 epoll을 지원하지 않는 경우.

	- epoll로 이벤트 기다리기
		> epoll_wait(): epoll 인스턴스와 연관된 fd에 대한 이벤트를 기다린다.
		====================================================================================
		#include <sys/epoll.h>

		int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)
		====================================================================================
		> 호출 시, timeout 밀리 초 동안, epfd(epoll 인스턴스)와 연관된 파일의 이벤트를 기다린다.
		> 호출 성공: events에 대한 해당 이벤트, 파일이 읽기나 쓰기가 가능한 상태인지를 나타내는 epoll_event 구조체에 대한 포인터가 기록되며, 
				   최대 maxevents만큼의 이벤트가 기록된다, 발생한 이벤트 개수를 반환
				   # epoll_event 구조체의 
				   		-> events: 발생한 이벤트
				   		-> data: epoll_ctl()을 호출하기 전에 설정한 값
		> 에러: -1 반환, errno 설정.
			$ EBADF: epfd가 유효한 fd가 아니다.
			$ EFAULT: events가 가리키는 메모리에 대한 쓰기 권한이 없을 경우
			$ EINTR: 시스템 콜이 완료되거나, timeout을 초과하기 전에 시그널이 발생해서 동작이 멈춘 경우
			$ EINVAL: epfd가 유효한 epoll 인스턴스가 아니거나 maxevents가 0 이하인 경우
		> timeout이 0인 경우: 이벤트가 발생하지 않아도, epoll_wait()는 즉시 반환하며 반환값 = 0.
		> timeout이 -1인 경우: 이벤트가 발생할 때까지 해당 호출은 반환되지 않음.


	- 에지 트리거와 레벨 트릐거
		> epoll_ctl()에서 event인자의 events 필드를 EPOLLET으로 설정. -> 이벤트 모니터가 레벨 트리거가 아닌 에지 트리거로 동작.
		> poll(), select()가 동작하는 방식: 레벨 트리거
		> 에지 트리거: 논블록킹 입출력을 활용하도록 하는 다른 프로그래밍 접근 방식을 요구하며 EAGAIN을 주의 깊게 확인해야 함.

			$ 레벨 트리거: 신호가 인가되어 특정 레벨을 유지할 때 발생(이벤트의 상태에 관심(신호의 레벨))
				# epoll: fd가 읽기 가능한 상태가 되었을 때 알림을 받음(상태의 지속이 알림을 발생).

			$ 에지 트리거: 신호가 하강되거나 상승하는 동안 발생(이벤트 자체(신호가 움직이는)
				# epoll: 읽을 수 있는 첫 번째 데이터가 들어오면 알림을 받음(상태의 변화).

	- 메모리에 파일 맵핑하기
	






