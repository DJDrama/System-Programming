[6] 고급 프로세스 관리
	(6.1) 프로세스 스케줄링
		- 프로세스 스케줄러
			$ 커널의 서브시스템
			$ 다음에 실행할 프로세스를 선택하기 위한 커널의 구성 요소
		- 실행 가능한 프로세스: 블록되지 않은 프로세스
			* 블록되지 않은 프로세스: 자고 있거나 커널로부터 입출력을 기다리고 있는 프로세스
		- 실행 가능하지 않은 상태
			1. 사용자와 상호 작용을 한다
			2. 파일을 자주 읽고 쓴다
			3. 요청한 리소스가 사용 가능할 때까지 오랫동안 기다려야 하는 네트워크 이벤트를 처리한다.
		
		- 단일 프로세서: 여러 프로세스를 번갈아 실행, 동시에 하나 이상의 프로세스가 실행 중이라는 착각을 불러 일으켜 멀티태스킹 구현
		- 멀티프로세서: 실제로 병렬적으로 수행

		- 멀티태스킹 운영체제
			$ 선점형
				# 실행 중인 프로세스를 멈추는 행위: 선점
				# 리눅스는 특정 프로세스가 언제 실행을 멈추고 다른 프로세스가 실행을 재개할지를 스케줄러가 결정하는 선점형 멀티태스킹 구현.
			$ 비선점형
				# 프로세스가 스스로 실행을 멈추기 전까지 계속 실행됨.
				# 프로세스가 자발적으로 실행을 잠시 쉬는 것을 양보(yield)라고 한다.(이를 운영체제에서 강제할 수 없다)
				* 단점: 프로그램이 욕심이 많거나 문제가 생긴 채로 너무 오랫동안 실행되고 있으면 멀티태스킹이 유지되지 못하거나 무기한으로 계속 실행되면 전체 시스템을 다운시킬 수 있다.

			* 최신 운영체제는 거의 선점형 멀티태스킹 방식을 사용한다.(리눅스 또한 마찬가지)

		- 현재 스케줄러: CFS(Completely Fair Scheduler) 스케줄러

	(6.1.1) 타임 슬라이스
		- 각 프로세스에 할당하는 타임 슬라이스: 시스템 전반의 동작 방식과 성능에 관한 중요한 변수
			* 시간을 너무 크게 쪼개면(타임 슬라이스가 너무 크다면) 프로세스는 다음 실행 시간까지 오래 기다려야 하며 동시 수행 능력을 떨어뜨림.
			* 시간을 너무 잘게 쪼개면(타임 슬라이스가 너무 작으면) 잦은 프로세스 전환으로 인해 일시적인 지역성과 같은 장점을 잃게 된다.

		- 큰 타임 슬라이스: 시스템이 처리할 수 있는 용량을 극대화하여 성능 향상을 꾀할 목적
		- 작은 타임 슬라이스: 빠른 응답속도를 확보하기 위한 목적

	(6.1.2) 입출력 위주 프로세스와 CPU 위주 프로세스
		- CPU 위주 프로세스: 타임 슬라이스를 끊임없이 계속 사용하는 프로세스
			$ 스케줄러에서 허락하는 시간을 모두 사용한다.
				# 예: while(1); (무한 루프)
				# 예: 수학, 과학 연산, 이미지 처리 등.
			$ 일시적인 지역성을 통해 캐시 적중률을 최대화하고 작업을 최대한 빨리 끝낼 수 있도록 큰 타임 슬라이스를 갈망

		- 입출력 위주 프로세스: 실행 시간보다 리소스를 사용하기 위해 기다리는 데 시간을 더 많이 사용하는데 이용.
			$ 파일이나 네트워크 입출력을 기다리거나
			$ 키보드 입력을 기다리거나
			$ 사용자가 마우스를 움직이기를 기다리거나
				# 예: cp, mv 같은 파일 유틸리티
				# 예: 입출력 수행을 요청하기 위한 몇 가지 시스템 콜
				# 예: 사용자의 입력을 계속 기다리는 여러 가지 GUI 어플리케이션
			$ 입출력 요청을 보내기까지는 아주 짧은 시간이면 충분하며 대부분의 시간을 커널 리소스를 얻기 위해 블록되므로 작은 타임 슬라이스

	(6.1.3) 선점형 스케줄링
		- 전통적인 유닉스 프로세스 스케줄링: 모든 실행 가능한 프로세스는 타임 슬라이스를 할당 받음.
		- 주어진 타임 슬라이스를 다 소진하면 커널은 그 프로세스를 잠시 멈추고 다른 프로세스를 실행.
		- 모든 프로세스는 반드시 계속 진행되어야 한다는 규칙
			$ 실행 가능한 프로세스가 없다면 커널은 타임 슬라이스를 다 소진한 프로세스에 다시 타임 슬라이스를 보충해주고 실행을 재개한다.
			$ 프로세스의 생성과 종료, 입출력에 의한 블록, 잠들었다가 다시 깨어남에 따라 실행 가능한 프로세스 목록에 들어갔다 나가기를 반복
			$ 모든 프로세스는 자기보다 우선순위가 높은 프로세스가 있을지라도 그 프로세스가 타임 슬라이스를 모두 소진하거나 블록된다면 결국 실행될 기회를 얻음.

	(6.2) CFS 스케줄러
		- 타임 슬라이스를 사용하지 않는 공정한 스케줄링 알고리즘 사용
			$ CPU 시간의 일부를 각 프로세스에 할당
			$ N개의 프로세스에 각각 1/N 만큼의 CPU 시간을 할당.
			$ 각 프로세스의 nice 값에 따라 가중치를 준다.
				# 기본값인 0을 그대로 사용하면, 가중치는 1이다. --> 할당 받는 CPU 시간에는 변화가 없다.
				# 값이 작으면, 우선순위가 높아진다 --> 가중치가 높아, 많은 CPU 시간 사용
				# 값이 크면, 우선순위가 낮아진다 --> 가중치가 낮아, 적은 CPU 시간 사용

		- 타킷 레이턴시(Target Latency): 한정된 시간
			$ 수행될 시간을 한정된 시간으로 나눈다.
				# 예: 타킷 레이턴시가 20밀리 초고, 우선순위가 같은 두 프로세스가 실행 가능하면 각각 10밀리초씩 CPU 시간을 할당받음. CFS 스케줄러는 한 프로세스를 10밀리 초 동안 실행하고 그다음에 다른 프로세스를 또 10밀리 초간 실행하고 이를 반복한다.
			$ 많은 프로세스가 있고, 타킷 레이턴시가 20밀리 초라면 매우 짧게 실행되게 된다.
				# 컨텍스트 스위칭 오버헤드 때문에 일시적인 지역성의 효과가 줄어들고 시스템의 전체 처리 성능은 심각할 만큼 지장받는다.
					--> 이 때문에 최소 단위가 존재한다.

		- 최소 단위(Minimum Granularity)
			$ 프로세스가 실행되는 최저 시간 단위
			$ CPU 시간과 관계 없이 적어도 최소 단위만큼 실행된다.
				--> 컨텍스트 스위칭으로 낭비되는 시간이 말도 안되게 길어지지 않도록 보장
				--> 공정성이 무너진다.

		* CFS 스케줄러는 CPU 시간을 할당한 덕에 공정성을 강제할 수 있다.

	(6.3) 프로세서 양보하기
		- 프로세스가 명시적으로 실행을 양보해서 스케줄러가 새로운 프로세스를 실행하도록 하는 시스템 콜 제공.
			================================================================================================
			#include <sched.h>

			int sched_yield(void);
			================================================================================================
			$ 호출: 현재 실행 중인 프로세스를 잠시 멈춘 다음 스케줄러가 다음에 실행할 새로운 프로세스를 선택하도록 한다.
			$ 다른 실행 가능한 프로세스가 없으면 sched_yield()를 호출한 프로세스의 실행이 즉시 재개된다.
			$ 성공: 0 반환
			$ 실패: -1 반환, errno 설정
			* 호출은 실패하지 않기에 항상 0을 반환.

	(6.3.1) 적당한 사용법

	(6.4) 프로세스 우선순위
		- nice: 프로세스의 우선순위를 낮춰 다른 프로세스가 CPU 시간을 좀 더 사용할 수 있도록 '친절하게 대한다'
		- nice 값: -20 ~ 19, 기본값은 0
		- 적을수록 우선순위가 높아지며 타임슬라이스가 커진다.
		- 클수록 우선순위가 낮아지며 타임슬라이스가 작아진다. --> 나머지 시스템에 친절한(nice) 프로세스가 된다.

	(6.4.1) nice()
		================================================================================================
		#include <unistd.h>

		int nice(int inc);
		================================================================================================
		- 호출 성공: inc 만큼 프로세스의 nice 값을 증가시키고 새롭고 갱신된 값을 반환.
		* root가 아닌 프로세스는 nice 값을 증가시켜 우선순위를 낮추는 작업만 가능
		- 호출 실패: -1 반환 <-> 하지만, nice()는 새로운 nice 값을 반환하므로 -1은 성공했을 때의 정상적인 반환값이기도 하다.
			* 그래서 errno를 확인해야 한다.
		- inc가 0이면, 현재 nice 값을 얻을 수 있다.

	(6.4.2) getpriority()와 setpriority()
		



			

