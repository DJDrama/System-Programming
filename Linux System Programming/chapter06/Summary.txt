[6] 고급 프로세스 관리
   (6.1) 프로세스 스케줄링
      - 프로세스 스케줄러
         $ 커널의 서브시스템
         $ 다음에 실행할 프로세스를 선택하기 위한 커널의 구성 요소
      - 실행 가능한 프로세스: 블록되지 않은 프로세스
         * 블록되지 않은 프로세스: 자고 있거나 커널로부터 입출력을 기다리고 있는 프로세스
      - 실행 가능하지 않은 상태
         1. 사용자와 상호 작용을 한다
         2. 파일을 자주 읽고 쓴다
         3. 요청한 리소스가 사용 가능할 때까지 오랫동안 기다려야 하는 네트워크 이벤트를 처리한다.
      
      - 단일 프로세서: 여러 프로세스를 번갈아 실행, 동시에 하나 이상의 프로세스가 실행 중이라는 착각을 불러 일으켜 멀티태스킹 구현
      - 멀티프로세서: 실제로 병렬적으로 수행

      - 멀티태스킹 운영체제
         $ 선점형
            # 실행 중인 프로세스를 멈추는 행위: 선점
            # 리눅스는 특정 프로세스가 언제 실행을 멈추고 다른 프로세스가 실행을 재개할지를 스케줄러가 결정하는 선점형 멀티태스킹 구현.
         $ 비선점형
            # 프로세스가 스스로 실행을 멈추기 전까지 계속 실행됨.
            # 프로세스가 자발적으로 실행을 잠시 쉬는 것을 양보(yield)라고 한다.(이를 운영체제에서 강제할 수 없다)
            * 단점: 프로그램이 욕심이 많거나 문제가 생긴 채로 너무 오랫동안 실행되고 있으면 멀티태스킹이 유지되지 못하거나 무기한으로 계속 실행되면 전체 시스템을 다운시킬 수 있다.

         * 최신 운영체제는 거의 선점형 멀티태스킹 방식을 사용한다.(리눅스 또한 마찬가지)

      - 현재 스케줄러: CFS(Completely Fair Scheduler) 스케줄러

   (6.1.1) 타임 슬라이스
      - 각 프로세스에 할당하는 타임 슬라이스: 시스템 전반의 동작 방식과 성능에 관한 중요한 변수
         * 시간을 너무 크게 쪼개면(타임 슬라이스가 너무 크다면) 프로세스는 다음 실행 시간까지 오래 기다려야 하며 동시 수행 능력을 떨어뜨림.
         * 시간을 너무 잘게 쪼개면(타임 슬라이스가 너무 작으면) 잦은 프로세스 전환으로 인해 일시적인 지역성과 같은 장점을 잃게 된다.

      - 큰 타임 슬라이스: 시스템이 처리할 수 있는 용량을 극대화하여 성능 향상을 꾀할 목적
      - 작은 타임 슬라이스: 빠른 응답속도를 확보하기 위한 목적

   (6.1.2) 입출력 위주 프로세스와 CPU 위주 프로세스
      - CPU 위주 프로세스: 타임 슬라이스를 끊임없이 계속 사용하는 프로세스
         $ 스케줄러에서 허락하는 시간을 모두 사용한다.
            # 예: while(1); (무한 루프)
            # 예: 수학, 과학 연산, 이미지 처리 등.
         $ 일시적인 지역성을 통해 캐시 적중률을 최대화하고 작업을 최대한 빨리 끝낼 수 있도록 큰 타임 슬라이스를 갈망

      - 입출력 위주 프로세스: 실행 시간보다 리소스를 사용하기 위해 기다리는 데 시간을 더 많이 사용하는데 이용.
         $ 파일이나 네트워크 입출력을 기다리거나
         $ 키보드 입력을 기다리거나
         $ 사용자가 마우스를 움직이기를 기다리거나
            # 예: cp, mv 같은 파일 유틸리티
            # 예: 입출력 수행을 요청하기 위한 몇 가지 시스템 콜
            # 예: 사용자의 입력을 계속 기다리는 여러 가지 GUI 어플리케이션
         $ 입출력 요청을 보내기까지는 아주 짧은 시간이면 충분하며 대부분의 시간을 커널 리소스를 얻기 위해 블록되므로 작은 타임 슬라이스

   (6.1.3) 선점형 스케줄링
      - 전통적인 유닉스 프로세스 스케줄링: 모든 실행 가능한 프로세스는 타임 슬라이스를 할당 받음.
      - 주어진 타임 슬라이스를 다 소진하면 커널은 그 프로세스를 잠시 멈추고 다른 프로세스를 실행.
      - 모든 프로세스는 반드시 계속 진행되어야 한다는 규칙
         $ 실행 가능한 프로세스가 없다면 커널은 타임 슬라이스를 다 소진한 프로세스에 다시 타임 슬라이스를 보충해주고 실행을 재개한다.
         $ 프로세스의 생성과 종료, 입출력에 의한 블록, 잠들었다가 다시 깨어남에 따라 실행 가능한 프로세스 목록에 들어갔다 나가기를 반복
         $ 모든 프로세스는 자기보다 우선순위가 높은 프로세스가 있을지라도 그 프로세스가 타임 슬라이스를 모두 소진하거나 블록된다면 결국 실행될 기회를 얻음.

   (6.2) CFS 스케줄러
      - 타임 슬라이스를 사용하지 않는 공정한 스케줄링 알고리즘 사용
         $ CPU 시간의 일부를 각 프로세스에 할당
         $ N개의 프로세스에 각각 1/N 만큼의 CPU 시간을 할당.
         $ 각 프로세스의 nice 값에 따라 가중치를 준다.
            # 기본값인 0을 그대로 사용하면, 가중치는 1이다. --> 할당 받는 CPU 시간에는 변화가 없다.
            # 값이 작으면, 우선순위가 높아진다 --> 가중치가 높아, 많은 CPU 시간 사용
            # 값이 크면, 우선순위가 낮아진다 --> 가중치가 낮아, 적은 CPU 시간 사용

      - 타킷 레이턴시(Target Latency): 한정된 시간
         $ 수행될 시간을 한정된 시간으로 나눈다.
            # 예: 타킷 레이턴시가 20밀리 초고, 우선순위가 같은 두 프로세스가 실행 가능하면 각각 10밀리초씩 CPU 시간을 할당받음. CFS 스케줄러는 한 프로세스를 10밀리 초 동안 실행하고 그다음에 다른 프로세스를 또 10밀리 초간 실행하고 이를 반복한다.
         $ 많은 프로세스가 있고, 타킷 레이턴시가 20밀리 초라면 매우 짧게 실행되게 된다.
            # 컨텍스트 스위칭 오버헤드 때문에 일시적인 지역성의 효과가 줄어들고 시스템의 전체 처리 성능은 심각할 만큼 지장받는다.
               --> 이 때문에 최소 단위가 존재한다.

      - 최소 단위(Minimum Granularity)
         $ 프로세스가 실행되는 최저 시간 단위
         $ CPU 시간과 관계 없이 적어도 최소 단위만큼 실행된다.
            --> 컨텍스트 스위칭으로 낭비되는 시간이 말도 안되게 길어지지 않도록 보장
            --> 공정성이 무너진다.

      * CFS 스케줄러는 CPU 시간을 할당한 덕에 공정성을 강제할 수 있다.

   (6.3) 프로세서 양보하기
      - 프로세스가 명시적으로 실행을 양보해서 스케줄러가 새로운 프로세스를 실행하도록 하는 시스템 콜 제공.
         ================================================================================================
         #include <sched.h>

         int sched_yield(void);
         ================================================================================================
         $ 호출: 현재 실행 중인 프로세스를 잠시 멈춘 다음 스케줄러가 다음에 실행할 새로운 프로세스를 선택하도록 한다.
         $ 다른 실행 가능한 프로세스가 없으면 sched_yield()를 호출한 프로세스의 실행이 즉시 재개된다.
         $ 성공: 0 반환
         $ 실패: -1 반환, errno 설정
         * 호출은 실패하지 않기에 항상 0을 반환.

   (6.3.1) 적당한 사용법

   (6.4) 프로세스 우선순위
      - nice: 프로세스의 우선순위를 낮춰 다른 프로세스가 CPU 시간을 좀 더 사용할 수 있도록 '친절하게 대한다'
      - nice 값: -20 ~ 19, 기본값은 0
      - 적을수록 우선순위가 높아지며 타임슬라이스가 커진다.
      - 클수록 우선순위가 낮아지며 타임슬라이스가 작아진다. --> 나머지 시스템에 친절한(nice) 프로세스가 된다.

   (6.4.1) nice()
      ================================================================================================
      #include <unistd.h>

      int nice(int inc);
      ================================================================================================
      - 호출 성공: inc 만큼 프로세스의 nice 값을 증가시키고 새롭고 갱신된 값을 반환.
      * root가 아닌 프로세스는 nice 값을 증가시켜 우선순위를 낮추는 작업만 가능
      - 호출 실패: -1 반환 <-> 하지만, nice()는 새로운 nice 값을 반환하므로 -1은 성공했을 때의 정상적인 반환값이기도 하다.
         * 그래서 errno를 확인해야 한다.
      - inc가 0이면, 현재 nice 값을 얻을 수 있다.

   (6.4.2) getpriority()와 setpriority()
      - 시스템 콜
         ================================================================================================
         #include <sys/time.h>
         #include <sys/resource.h>
      
         int getpriority(int which, int who); // 지정한 프로세스 중에서 가장 높은 우선순위 반환.
         int setpriority(int which int who, int prio); // 지정한 모든 프로세스의 우선순위를 prio 값으로 지정.
         // * CAP_SYS_NICE 기능 사용 가능한 프로세스만이 우선순위를 올릴 수 있음.
         // * 위 프로세스만이 호출한 사용자가 소유하지 않은 프로세스의 우선순위를 높이거나 낮출 수 있다.
         ================================================================================================
         $ which 인자값
            # PRIO_PROCESS
            # PRIO_PGRP
            # PRIO_USER
         
         $ who 인자값
            # 프로세스 ID
            # 프로세스 그룹 ID
            # 사용자 ID
            * 값이 0이면 현재 프로세스, 그룹, 사용자 ID로 해석.
         
         $ getpriority는 실패 시 -1 반환, 성공했을 때도 -1 반환 가능 (errno를 이용하여 에러 검사하자)
   
   (6.4.3) 입출력 우선순위
      - IO 스케줄러는 IO 우선순위를 결정하기 위해 프로세스의 nice 값을 사용
      - 모든 IO 스케줄러가 IO 우선순위를 지원하는 것은 아니다
         $ CFQ 입출력 스케줄러가 이를 지원.
         $ 현재 다른 표준 스케줄러는 IO 우선순위를 지원하지 않음.
   
   (6.5) 프로세서 친화
      - 멀티 프로세서 사용하는 시스템의 프로세스 스케줄러 -> 반드시 프로세스가 어떤 CPU에서 실행될지 결정해야 함
         $ 어떤 프로세스가 한 CPU에 스케줄되면 스케줄러는 앞으로도 같은 CPU에서 실행되어야 한다.
            # 프로세스를 다른 CPU로 이전하는 데 손실이 발생하기 때문.
         
      - 가장 큰 손실: 캐시효과와 관련 있음
         $ SMP 시스템의 설계에 의하면 CPU에 딸린 캐시는 서로 분리되어 있다.   
            * 한 CPU 캐시 안에 있는 애용은 다른 CPU의 캐시에는 존재하지 않음.
            --> 프로세스가 다른 CPU로 옮겨지고 메모리에 새로운 데이터를 쓰면, 이전 CPU의 캐시에 있는 데이터는 무쓸모
               (이전 캐시에 의존하면 데이터 손상 초래)
            
            # 예방하기 위해 메모리의 새로운 내용을 캐시할 때마다 다른 쪽 캐시를 무효로 만듦.
            # 프로세스가 다른 CPU로 옮겨지면 관련 2가지 부대 비용 발생
               1. 이동한 프로세스의 캐시에 있는 데이터는 더 이상 접근할 수 없음
               2. 이전 CPU의 캐시에 있던 내용을 무효로 해야 함.
               (이런 손실 때문에 스케줄러는 최대한 프로세스를 특정 CPU에 유지하려고 한다)
            
            # 불균형 개선하기 위해 로드밸런싱 사용
               @ 불균형: 한 CPU는 바쁘지만 다른 CPU는 놀고 있다면 덜 바쁜 CPU 쪽으로 프로세스를 옮기는게 합리적.
               @ 로드밸런싱: 불균형을 개선하기 위해 언제 프로세스를 옮길지를 결정하는 작업(SMP머신의 성능에서 매우 중요한 역할을 함)
      
      - 프로세스 친화도(Processor Affinity)
         $ 프로세스를 꾸준히 같은 CPU에 스케줄링할 가능성
         $ 느슨한 친화도: 프로세스를 같은 CPU에 계속 스케줄링하려는 스케줄러의 자연스러운 경향
            * 리눅스 스케줄러는 최대한 오랫동안 같은 CPU에서 같은 프로세스를 스케줄링하려고 함
            * 프로세스를 다른 CPU로 옮기는 것은 해당 CPU에 심각하게 부하가 걸려 불균형 초래 정도 상태에만 수행해야 함.
         $ 엄격한 친화도: 어떤 프로세스를 특정 CPU에 연결해서 커널이 이 관계를 강제하도록 설정하는 것.
            # 프로세스가 캐시와 아주 민감하게 연결되어 계속 같은 CPU에서 실행되기를 원하는 경우
   
   (6.5.1) shced_getaffinity()와 sched_setaffinity()
      - 프로세스는 어떤 CPU에서도 실행될 수 있다.
   
   (6.6) 실시간 시스템
      - 실시간 시스템: 운영 시 지켜야 할 최소한의 응답속도가 보장되어야 함.
   
   (6.6.1) 실시간 시스템의 종류
      - 하드 실시간
         $ 최소 응답시간 고수
         $ 최소 응답시간 넘기면 실패로 간주(심각한 버그)
         $ 구분하기 쉬움(의료 장비, 군사 무기 시스템, 신호처리 등)
         
      - 소프트 실시간
         $ 최소 응답시간 넘기더라도 치명적인 실패로 간주하지 않음.
         $ 구분하기 어려움(최소 응답시간을 넘기면 프레임 저하를 초래, 재생은 계속 된다)
      
      * 구분 기준은 꽤나 모호함.
      
      - 실시간 시스템: 반드시 빠를 필요 없다.
      - 최소 응답시간의 길이가 하드 / 소프트 실시간 시스템을 구분짓지는 않음.
   
   (6.6.2) 레이턴시, 지터, 최소 응답시간
      - 레이턴시(Latency): 명령이 내려졌을 때 실행을 시작하기까지의 시간
         * if(레이턴시 <= 최소응답시간) "시스템은 제대로 동작"
         
         $ 하드 실시간 시스템: (레이턴시 == 최소응답시간)
         $ 소프트 실시간 시스템: 레이턴시가 다소 가변적.(단순히 주어진 최소 응답시간 안에 응답하는 것이 목표)
         
         $ 측정하기 까다로움(명령이 언제 내려졌는지를 정확히 알아야 하기 때문)
         $ 지터(Jitter): 대신 응답 간의 시간 차이를 측정(연속적인 이벤트 간의 시간 편차)
      
      - 하드 실시간 시스템
         $ 매우 짧은 지터를 드물지 않게 목격할 수 있음(명령이 내려진 시점에서 얼마간의 시간이 지난 다음에 응답하기 때문)
            --> 지터가 0이고 레이턴시가 최소 응답시간과 같도록 설계(레이턴시가 최소 응답시간을 넘기면 동작 실패)
      
      - 소프트 실시간 시트템
         $ 지터에 민감하다.
         $ 이상적인 소프트 실시간 시스템: 대부분 응답시간이 최소 응답시간보다 아주 짧거나 초과하지 않음.
   
      

   (6.6) 리눅스의 실시간 지원
   
   (6.6.4) 리눅스 스케줄링 정책과 우선순위
      - 실시간 스케줄링
      	$ SCHED_FIFO
      	$ SCHED_RR
      - 비실시간 스케줄링
      	$ SCHED_OTHER

      - 모든 프로세스: 고유의 우선순위를 가짐
      - 일반 어플리케이션: 우선순위는 항상 0
      - 실시간 프로세스: 1~99
      - 리눅스 스케줄러: 항상 가장 높은 우선순위의 프로세스를 실행
      * 실행 가능한 실시간 프로세스가 항상 일반 프로세스보다 먼저 실행된다.

      - FIFO 정책
      	 $ Time Slice를 필요로 하지 않는 매우 단순한 실시간 프로세스 스케줄링 정책
      	 $ 더 높은 우선순위의 프로세스가 실행 가능한 상태가 되지 않는 한 계속 실행된다.
      	 
      	 (규칙)
      	 	1. 우선순위가 높다면 항상 실행된다.(실행 가능한 상태의 프로세스는 일반 프로세스보다 우선 실행된다)
      	 	2. 프로세스가 블록되거나 sched_yeild()를 호출하거나 더 높은 우선순위의 프로세스가 실행 가능한 상태가 되기 전까지 계속 실행된다.
      	 	3. 블록되면 실행 가능한 프로세스 목록에서 제거한다. 다시 실행 가능 상태가 되면 같은 우선순위를 가지는 프로세스 목록의 끝에 들어간다.
      	 	4. sched_yield()를 호출한 프로세스와 같은 우선순위를 가지는 프로세스가 없다면 의미가 없다.
      	 	5. 높은 우선순위의 프로세스가 실행을 중단하면 선점되었던 FIFO 프로세스가 실행을 재개한다.
      	 	6. 고유의 우선순위가 바뀌면 같은 우선순위의 프로세스 목록의 제일 앞에 위치한다.

      	 * 시스템 내에서 가장 높은 우선순위를 가진다면 원하는 만큼 계속 실행될 수 있다.

      - 라운드 로빈 스케줄링 정책
      	$ 각 프로세스에 타임 슬라이스를 배분한다.
      	$ 타임 슬라이스를 다 소진하면 같은 우선순위의 프로세스 목록에서 다음 프로세스를 실행한다.
      	$ 타임 슬라이스 모두 소진 시 실행 중단, 같은 우선순위를 가지는 프로세스 목록의 끝으로 이동.

      - 표준 스케줄링 정책
      	$ 일반 프로세스는 고유의 우선순위로 0을 가진다.(FIFO나 RR 프로세스는 실행 중인 일반 프로세스를 선점할 수 있다.)
      	$ nice 값을 이용하여 일반 프로세스 간의 우선순위를 적용한다.(nice 값은 고유의 우선순위(값이 0인)에 영향을 미치지 않는다.)

      - 배치 스케줄링 정책
      	$ 일괄 또는 유휴 스케줄링 정책.
      	$ 시스템에 실행 가능한 프로세스가 없을 때만 실행된다.
      	* 타임 슬라이스를 다 소진하면 우선순위가 가장 낮은 프로세스도 실행될 수 있다.

      - 리눅스 스케줄링 정책 설정하기
      	$ 함수를 통해 프로세스에서 리눅스 스케줄링 정책을 조작할 수 있다.
      		# sched_getscheduler()
      			@ pid로 지정한 프로세스의 스케줄링 정책을 반환한다.
      			@ pid가 0이면 호출한 프로세스의 스케줄링 정책을 반환한다.
      		# sched_setscheduler()
      			@ pid로 설정한 프로세스의 스케줄링 정책을 설정한다.
      			@ 정책은 sp 인자로 설정.
      			@ pid가 0이면 호출한 프로세스의 스케줄링 정책을 설정한다.
      			* sched_other 제외한 다른 스케줄링 정책을 적용하려면 CAP_SYS_NICE 기능이 필요
      			* 실시간 프로세스는 일반적으로 root 사용자가 실행한다.
   
	(6.6.5) 스케줄링 인자 설정하기
		- 이미 설정된 스케줄링 정책과 관련된 인자를 설정하거나 설정값을 읽기 위한 함수
			$ sched_getparam()
				# sp 인자를 통해 pid로 지정한 프로세스의 스케줄링 설정값을 반환.
				# pid가 0이면 함수를 호출한 프로세스의 스케줄링 설정값을 반환.
			$ sched_setparam()
				# 스케줄링 인자를 변경할 때 유용

		- 유효한 우선순위 범위 확인하기
			$ 유효한 우선순위 값의 범위를 확인할 수 있는 두가지 시스템 콜
				1. int sched_get_priority_min(int policy) : 최소 우선순위 값 반환
				2. int sched_get_priority_max(int policy) : 최대 우선순위 값 반환
			$ 우선순위 값이 클수록 높은 우선순위

	(6.6.6) sched_rr_get_interval()
		- 어떤 프로세스의 타임 슬라이스가 얼마나 남아 있는지 확인할 수 있는 인터페이스
			$ int sched_rr_get_interval(pid_t pid, struct timespec *tp);
				@ pid 프로세스에 할당된 타임 슬라이스의 길이를 tp 포인터가 가리키고 있는 timespec 구조체에 저장하고 0을 반환.

	(6.6.7) 실시간 프로세스의 주의점
		- 실시간 프로그램이 무한 루프에 빠지면 시스템이 반응하지 않음.

		(주의사항)
			1. 무한히 실행되지 않도록 신경쓰자.
			2. 실시간 프로세스는 가장 비싼 비용으로 실행되므로, 설계에 신경을 써야 한다.
			3. 바쁜대기(busy waiting: 상태가 바뀌기만을 기다리는)를 사용할 때 주의하자.
			4. 그 실시간 프로세스보다 우선순위가 높은 터미널을 하나 열어놓자. 비상 사태가 발생해도 터미널은 사용자 입력에 반응, 문제가 된 프로세스를 종료시킬 수 있다.
			5. util-linux 패키지의 chrt 유틸리는 쉽게 다른 프로세스의 실시간 속성을 가져오거나 설정할 수 있다. --> 우선순위를 변경할 수 있다.

	(6.6.8) 결정론
		- '결정론'에 실시간 프로세스는 크게 의존한다.
		- '결정론적': 주어진 입력이 같다면 항상 같은 결과를 같은 시간 안에 도출한다는 의미.
			$ 여러개의 프로세서, 페이징, 스와핑, 그리고 멀티태스킹은 주어진 명령이 얼마나 걸릴지 예측할 수 없게 만든다.

		(실시간 어플리케이션은 예측할 수 없는 부분과 최악의 지연을 제한하려고 한다)
			<1> 선행 폴트 데이터와 메모리 락
			<2> CPU 친화도와 실시간 프로세스

	(6.7) 리소스 제한
		- 프로세스가 소비하는 열 수 있는 파일 개수, 메모리 페이지, 대기 중인 시그널 등과 같은 커널 리소르를 제한한다.
			$ 커널은 이 제한을 초과하는 프로세스의 리소르 소비를 허용하지 않는다.(open()이 리소스 제한에서 허용하는 수치를 초과하면 해당 호출 실패)

		- 제한 설정 시스템 콜
			1. getrlmit(): 설정된 리소스 제한에 대한 내용
			2. setrlimit()

		- 커널은 리소스 제한을 프로세스 단위로 관리(자식은 포크될 때 제한값을 상속받으며 exec 호출 뒤에도 유지된다)

		- 기본 제한
			(기본 제한값 변경 두가지 요인)
				1. 어떤 프로세스라도 자유롭게 소프트 제약을 0부터 하드 제한값 까지 늘리거나 하드 제한값을 줄일 수 있다.
				2. root는 하드 제한을 원하는 값으로 설정할 수 있다.

	(6.7.2) 제한 설정과 조회
		- 소프트 제한값이 0, 하드 제한값이 -1(무한)이면 소프트 제한은 어떤 값으로든 설정할 수 있다.






         
