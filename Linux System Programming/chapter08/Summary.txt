[08] 파일과 디렉터리 관리
	(8.1) 파일과 메타데이터
		- inode
			$ inode 번호: 파일시스템에서 유일한 숫자 값
			$ 파일은 inode를 참조
			$ 유닉스 계열 파일시스템에서 디스크에 위치한 물리적인 객체
			$ 리눅스 커널 내부의 자료구조로 표현되는 개념적인 객체
			$ 파일의 접근 권한, 마지막 접근 시간, 소유자, 그룹, 크기, 파일의 데이터 위치와 같은 메타데이터를 저장
			$ inode에는 파일 이름이 없다. 파일 이름은 디렉터리 엔트리에 저장된다.
			$ ls -i 를 통해 확인.

			* 다른 파일 시스템에는 같은 inode 번호가 있을 수도 있다.

	(8.1.1) stat 함수
		==============================================================================================================
		#include <sys/types.h>
		#include <sys/stat.h>
		#include <unistd.h>

		int stat(const char *path, struct stat *buf); 	// path로 지정한 파일의 정보 반환
		int fstat(int fd, struct stat *buf); 			// fd로 지정한 파일의 정보 반환
		int lstat(const char *path, struct stat *buf);	// 심벌링 링크일 경우, 링크가 가리키고 있는 파일이 아닌, 링크 자체의 정보를 반환
		==============================================================================================================
		- 각 함수는 파일 관련 정보를 반환.
		- 각 함수는 사용자가 제공한 stat 구조체에 정보를 저장
		- stat 구조체는 <sys/stat.h> 파일에서 include 하는 <bits/stat.h> 헤더 파일에 정의되어 있다.
			==============================================================================================================
			struct stat{
				dev_t st_dev;			// 파일을 포함하는 device ID (실제 디바이스에 파일이 존재하지 않으면 0)
				ino_t st_ino;			// inode 번호
				mode_t st_mode;			// 권한
				nlink_t st_nlink;		// 하드 링크 개수
				uid_t st_uid;			// 파일 소유자 ID
				gid_t st_gid;			// 파일 소유그룹 ID
				dev_t st_rdev;			// (특수 파일인 경우) Device ID
				off_t st_size;			// 파일 전체 바이트
				blksize_t st_blksize;	// 파일 시스템 입출력을 위한 블록 크기
				blkcnt_t st_blocks;		// 할당된 블록 개수
				time_t st_atime;		// 최종 접근 시간
				time_t st_mtime;		// 최종 변경 시간
				time_t st_ctime;		// 최종 상태 변경 시간 (마지막으로 파일의 메타데이터를 변경한 시간)
			}
			==============================================================================================================

		- 호출 성공: 0 반환, stat 구조체에 파일의 메타데이터를 저장한다.

	(8.1.2) 권한
		- 주어진 파일의 권한 값을 변경
			==============================================================================================================
			#include <sys/types.h>
			#include <sys/stat.h>

			int chmod(const char *path, mode_t mode); 	// 변경할 파일의 절대 경로나 상대 경로 path를 인자로 받음.
			int fchmod(int fd, mode_t mode);			// 변경할 파일의 파일 디스크립터를 fd 인자로 받음.
			==============================================================================================================
			- 권한을 mode 값으로 설정한다.
			- mode: stat 구조체의 st_mode 필드에서 반환하는 값과 동일.
				예) S_IRUSR | S_IRGRP : 소유자와 그룹의 읽기 권한.
			- 파일의 권한을 변경하려면 chmod(), fchmod() 호출 프로세스의 유효 ID가 파일의 소유자와 일치하거나, CAP_FOWNER 기능을 사용할 수 있어야 함.
			- 호출 성공: 0 반환
			- 실패: -1 반환, errno 설정.

	(8.1.3) 소유권
		- 소유자, 그룹 ID 변경 (st_uid, st_gid)
			==============================================================================================================
			#include <sys/types.h>
			#include <unistd.h>

			/* path로 지정한 파일의 소유권 변경 */
			int chown(const char *path, uid_t owner, gid_t group);		// 링크가 가리키는 파일의 소유권 변경
			int lchown(const char *path, uid_t owner, gid_t group);		// 심벌릭 링크 자체의 소유권 변경

			/* fd로 지정한 파일의 소유권 변경 */
			int fchown(int fd, uid_t owner, gid_t group);				
			==============================================================================================================
			- 호출 성공: 0 반환
			- ownwer, group에 -1을 설정하면, 해당 소유권 변경 작업은 이루어지지 않는다.
				예) chwon("manifest.txt", -1, gr->gr_gid); // owner에는 -1 값이 넘겨졌으며, 파일 소유자의 소유권은 변경되지 않는다.
			- owner, group에 0을 설정하면, 소유권은 모두 root으로 변경된다.
				예) fchown(fd, 0, 0);
			- 에러: -1, errno 설정.
			* 보통 CAP_CHOWN 기능이 있는 프로세스(보통은 root 프로세스)만이 파일의 소유자를 변경할 수 있다.

	(8.1.4) 확장 속성
		- xattrs
		- 파일과 관련한 키 / 값을 연관짓는 메커니즘 제공
		- 흥미로운점: 사용자 영역 앱이 임의로 키 / 값을 생성하고 읽고 쓸 수 있다는 점
		- 파일 시스템은 저마다의 방식으로 확장 속성을 저장하지만, 커널은 확장 속성 인터페이스 이면에서 이런 차이를 추상화하는 방식으로 차이점을 감춘다.
			예) ext4 파일시스템은 inode의 빈 공간에 확장 속성을 저장한다.(inode 공간이 꽉 차면 ext4 파일시스템은 확장 속성을 추가 블록에 저장)
			$ 이 특징은 확장 속성을 아주 빠르게 읽을 수 있도록 함
			$ 파일시스템의 블록이 가지고 있는 inode는 애플리케이션이 파일에 접근할 때마다 디스크에서 메모리로 읽어 들이기 때문에 확장 속성은 자동으로 메모리에 올라오고 추가적인 부하없이 바로 접근 가능.

		- 키와 값
			$ 확장 속성은 유일한 키로 구분된다.
			$ 키는 유효한 UTF-8 문자열
			$ 키는 '네임스페이스.속성' 형태를 취함
				# 모든 키는 반드시 유효한 네임스페이스와 마침표로 시작해야 한다.
				예) user.mime_type

		- 파일시스템에서 MIME 타입을 저장하는 옛 방법과 새로운 방법
			$ 파일의 포맷을 알아내려면, 윈도우즈 같은 시스템에서는 파일의 확장자를 살펴본다
			$ 전통과 보안 때문에 유닉스 시스템은 파일을 검사해서 타입을 해석 --> MIME 타입 스니핑

		- 리눅스는 현재 네 가지 확장 속성 네임스페이스를 정의
			1. system
				# ACL(Access Control List)과 같은 확장 속성을 활용하는 커널 기능을 구현하기 위해 사용
			2. security
				# SELinux와 같은 보안 모듈을 구현하기 위해 사용(CAP_SYS_ADMIN 기능을 가진 프로세스만이 이 값을 쓸 수 있음)
			3. trusted
				# 제한된 정보를 사용자 영역에 저장(CAP_SYS_ADMIN 기능이 있는 프로세스만이 이 속성을 읽거나 쓸 수 있음)
			4. user
				# 일반적인 프로세스가 사용하는 표준 네임스페이스
				# 심벌릭 링크나 디바이스 파일이 아닌 일반 파일에 대해서만 user 네임스페이스의 확장 속성에 값을 쓸 수 있다.

	(8.1.5) 확장 속성 연산
		- POSIX는 앱에서 파일의 확장 속성을 다룰 수 있는 네 가지 연산 제공
			1. 주어진 파일에 대한 모든 확장 속성 키 목록 반환
			2. 주어진 파일과 키에 해당하는 값 반환
			3. 주어진 파일과 키, 값을 받아서 그 값을 해당 키에 저장
			4. 주어진 파일과 키에 해당하는 확장 속성을 제거
		
		- POSIX는 각 연산을 위한 세 가지 시스템 콜 제공
			1. 주어진 파일 경로로 동작하는 버전: 경로가 심벌릭 링크면 링크가 가리키는 대상으로 동작(일반적 방식)
			2. 주어진 파일 경로로 동작하는 버전: 경로가 심벌릭 링크면 링크 그 자체를 대상으로 동작한다(l(알파벳 l)로 시작하는 시스템 콜의 표준 변종)
			3. 주어진 파일 디스크립터로 동작하는 버전(f로 시작하는 표준 변종)

		- 확장 속성 읽어오기
			==============================================================================================================
			#include <sys/types.h>
			#include <attr/xattr.h>

			/* 
			*	path 파일에서 이름이 key인 확장 속성을 읽어 크기가 size 바이트인 value 버퍼에 저장 (실제 읽어온 값의 크기를 반환) 
			*	size가 0이면, value에 확장 속성을 저장하지 않고 값의 크기만 반환. 
			*		--> 키 값을 저장하는 데 필요한 버퍼의 크기를 얻을 수 있다.
			*			--> 이 크기를 이용하여 버퍼를 필요한 크기로 할당하거나 크기 조절 가능.
			*/
			ssize_t getxattr(const char *path, const char *key, void *value, size_t size);

			/*
			*	getxattr()과 동일하지만, path 파일이 심벌릭 링크인 경우 링크 그 자체의 확장 속성을 반환.
			*	user 네임스페이스에 있는 속성은 심벌릭 링크에는 적용할 수 없어서 해당 함수는 잘 쓰이지 않음. 
			*/
			ssize_t lgetxattr(const char *path, const char *key, void *value, size_t size);

			/* 
			*	fd를 대상으로 동작하며 나머지는 getxattr()과 동일
			*/
			ssize_t fgetxattr(int fd, const char *key, void *value, size_t size);
			==============================================================================================================
			$ 호출 성공: 이름이 key인 확장 속성을 읽어 크기가 size 바이트인 value 버퍼에 저장
			$ 에러 발생: -1 반환, errno 설정

		- 확장 속성 쓰기
			==============================================================================================================
			#include <sys/types.h>
			#include <attr/xattr.h>

			/* 
			*	path에서 확장 속성 key를 크기가 size 바이트인 value로 설정.
			*	flags 필드는 호출 동작 방식을 변경.
			*		- XATTR_CREATE: 확장 속성이 이미 존재할 경우 호출 실패
			*		- XATTR_REPLACE: 확장 속성이 존재하지 않을 경우 호출 실패.
			*		- 0: 기본 동작으로 생성과 대체 모두 허용.
			*/
			int setxattr(const char *path, const char *key, void *value, size_t size, int flags);

			/*
			*	심벌릭 링크 그 자체의 확장 속성을 설정
			*/
			int lsetxattr(const char *path, const char *key, void *value, size_t size, int flags);

			/*
			*	fd에 대해서 동작.
			*/
			int fsetxattr(int fd, const char *key, void *value, size_t size, int flags);
			==============================================================================================================
			$ 호출 성공: 0 반환
			$ 에러 발생: -1 반환, errno 설정

		- 파일의 확장 속성 목록 구하기
			==============================================================================================================
			#include <sys/types.h>
			#include <attr/xattr.h>

			/* 
			*	path로 지정한 파일에 관련된 확장 속성 키 목록 반환.
			*	목록은 길이가 size 바이트인 list 버퍼에 저장되며 실제 list의 크기를 바이트 단위로 반환.
			*	list에 반환된 확장 속성 키는 각각 null 문자로 끝나므로 list의 내용은 다음과 같음
			*		예) "user.md5_sum\0user.mime_type\0system.posix_acl_default\0"
			*	size 0: 필요한 버퍼 크기 구하기 --> 함수 호출 결과로 전체 키 목록의 길이가 반환됨.
			*/
			ssize_t listxattr(const char *path, char *list, size_t size);

			/*
			*	심벌릭 링크 그 자체의 확장 속성 목록 반환.
			*/
			ssize_t llistxattr(const char *path, char *list, size_t size);

			/*
			*	fd에 대해서 동작.
			*/
			ssize_t flistxattr(int fd, char *list, size_t size);
			==============================================================================================================
			$ 에러 발생: -1 반환, errno 설정

		- 확장 속성 삭제하기(특정 key 속성 제거)
			==============================================================================================================
			#include <sys/types.h>
			#include <attr/xattr.h>

			/*
			*	path 파일에서 확장 속성 key를 삭제
			*/
			int removexattr(const char *path, const char *key);

			/*
			*	심벌릭 링크 그 자체의 확장 속성을 제거
			*/
			int lremovexattr(const char *path, const char *key);

			/*
			*	fd에 대해서 동작.
			*/
			int fremovexattr(int fd, const char *key);
			==============================================================================================================
			$ 호출 성공: 0 반환
			$ 에러 발생: -1 반환, errno 설정

	(8.2) 디렉터리
		- 유닉스에서 디렉터리: 각각 inode 번호에 맵핑된 파일 이름 목록을 가지고 있는 단순한 개념
		- 각 파일은 디렉터리 엔트리(Directory Entry)라고 한다
		- 각 이름과 inode 맵핑은 링크라고 한다.

		* 사용자가 어떤 디렉터리에서 파일을 열면, 커널은 그 디렉터리의 목록에서 파일 이름을 찾아서 이에 대응하는 inode 번호를 찾음
			--> 커널은 이렇게 얻은 파일시스템의 inode 번호로 디바이스에서 파일의 물리적인 위치를 찾아냄.

		- 디렉터리는 다른 디렉터리를 포함할 수 있음
			$ 모든 디렉터리는 어떤 부모 디렉터리의 하위 디렉터리가 된다.
			$ 파일시스템의 최상위 디렉터리인 / 디렉터리만 예외다(Root 디렉터리)

		- 경로 이름은 파일 이름과 하나 이상의 부모 디렉터리로 이루어진다.
		- 절대 경로: 루트 디렉터리에서부터 시작하는 경로 이름
		- 상대 경로: 루트 디렉터리로 시작하지 않는 경로 이름
			$ 현재 작업 디렉터리가 상대 경로의 시작 지점으로 사용됨.

		- 파일과 디렉터리 이름: '/'(디렉터리를 구분하는)와 null 문자(이름 끝을 나타내는)를 제외한 아무 문자 사용 가능.
			* 일반적인 관례: ASCII 문자만 사용

		- 모든 디렉터리는 .과 ..이라는 두 가지 특수 디렉터리 포함
			- .: 디렉터리 자신을 참조
			- ..: 현재 디렉터리의 상위 디렉터리 참조

	(8.2.1) 현재 작업 디렉터리
		- CWD(Current Working Directory): 모든 프로세스는 최초에 부모 프로세스로부터 상속받는 현재 디렉터리를 가짐.
			$ 커널이 상대 경로를 결정하는 기준점.

		- 현재 작업 디렉터리 알아내기 1
			==============================================================================================================
			#include <unistd.h>

			/*
			*	size가 0이면 현재 작업 디렉터리를 저장할 만큼 충분한 버퍼를 할당한 다음 현재 작업 디렉터리 저장.
			*		--> free로 버퍼를 해제해야 함.
			*/
			char * getcwd(char *buf, size_t size); 
			==============================================================================================================
			$ 호출 성공: 크기가 size 바이트이고 buf 포인터가 가리키는 버퍼에 현재 작업 디렉터리를 절대 경로로 복사한 다음 buf 포인터를 반환
			$ 호출 실패: NULL 반환, errno 설정

		- 현재 작업 디렉터리 알아내기 2 (리눅스에서만 제공)
			==============================================================================================================
			#define _GNU_SOURCE
			#include <unistd.h>

			char * get_current_dir_name(void);
			==============================================================================================================

		- 현재 작업 디렉터리 바꾸기
			==============================================================================================================
			#include <unistd.h>

			int chdir(const char *path);	// 디렉터리 경로를 인자로 받음 (path는 절대 경로, 상대 경로 모두 가능)
			int fchdir(int fd);				// 파일 디스크립터를 인자로 받음
			==============================================================================================================
			$ 호출 성공: 0 반환
			$ 호출 실패: -1 반환, errno 설정

			* 이런 시스템 콜은 현재 실행 중인 프로세스에만 미침.

	(8.3.3) 디렉터리 생성하기
		- 리눅스는 POSIX에서 정의한 디렉터리를 생성하는 시스템 콜을 제공
			==============================================================================================================
			#include <sys/stat.h>
			#include <sys/types.h>

			int mkdir(const char *path, mode_t mode);
			==============================================================================================================
			$ 호출 성공: 상대 경로나 절대 경로인 path 디렉터리를 생성하고 권한 비트를 mode로 설정한 다음(현재 umask 적용) 0 반환
			$ 리눅스에서는 새로 생성하는 디렉터리의 권한 비트는 (mode & ~umask & 01777)로 설정
			$ 실제로 프로세스에 설정된 umask를 mkdir()을 호출해서 덮어쓰지 못하게 한다.
			$ 만약 새로운 디렉터리의 부모 디렉터리에 sgid(set group id)가 설정되어 있거나 파일시스템이 bsdgroups로 마운트되었다면 새로운 디렉터리는 부모로부터 그룹을 상속받는다.
				<-> 그렇지 않으면 프로세스의 유효 그룹 ID가 새로운 디렉터리에 적용된다.
			$ 에러: -1 반환, errno 설정

	(8.2.3) 디렉터리 삭제하기
		- POSIX에서 정의한 rmdir()은 파일시스템 구조에서 디렉터리를 삭제한다.
			==============================================================================================================
			#include <unistd.h>

			int rmidr(const char *path);
			==============================================================================================================
			$ 호출 성공: 파일시스템에서 path 삭제하고 0 반환
			* path로 명시한 디렉터리는 반드시 비어 있어야 하며 .이나 ..은 제외함.
			* rm -r 처럼 재귀적으로 삭제할 수 있는 시스템 콜은 없다. --> 수동으로 DFS를 숭핸 다음 말단부터 모든 파일과 이렉터리를 삭제하면서 올라와야 한다.
			* 디렉터리에 있는 파일부터 모두 삭제한 다음에 디렉터리를 삭제하는 단계에서 rmdir()을 사용.
			$ 에러: -1 반환, errno 설정

	(8.2.4) 디렉터리 내용 읽기
		- ls나 파일 저장 대화상자 등을 구현, 주어진 디렉터리 내의 모든 파일을 다루거나, 주어진 패턴에 일치하는 파일을 찾을 때 유용.
			==============================================================================================================
			#include <sys/types.h>
			#include <dirent.h>

			DIR * opendir(const char *name);
			==============================================================================================================
			$ 호출 성공: 주어진 디렉터리를 나타내는 디렉터리 스트림이 만들어진다.
				# 디렉터리 스트림: 디렉터리를 연 파일 디스크립터, 몇 가지 메타데이터 그리고 내용을 저장할 버퍼 등을 담고 있다.
					--> 스트림에서 파일 디스크립터를 얻어오는 것도 가능.
							==============================================================================================
							#define _BSD_SOURCE /* or _SVID_SOURCE */
							#include <sys/types.h>
							#include <dirent.h>

							int dirfd(DIR *dir);
							==============================================================================================

		- 디렉터리 스트림에서 읽어오기
			$ opendir()로 디렉터리 스트림을 만들고 나면, readdir()을 사용해서 디렉터리의 엔트리를 읽어올 수 있다.
			$ readdir(): 주어진 DIR 객체에서 엔트리를 하나씩 읽어서 반환
				==============================================================================================
				#include <sys/types.h>
				#include <dirent.h>

				struct dirent * readdir(DIR *dir);
				==============================================================================================
				# 호출 성공: dir이 가리키는 디렉터리에서 다음 엔트리를 하나 읽어옴.
				# 호출 실패: NULL 반환 (디렉터리의 모든 엔트리를 읽어도 NULL을 반환하기에 함수 호출 전 errno를 0으로 설정한 다음 호출 후 확인 필요)
				# dirent 구조체
					@ 하나의 디렉터리 엔트리를 가리킨다.
						==============================================================================================
						struct dirent {
							ino_t d_ino;				/* inode 번호 */
							off_t d_off;				/* 다음 디렉터리 엔트리의 오프셋 */
							unsigned short d_reclen;	/* 이 항목의 길이 */
							unsigned char d_type;		/* 파일 타입 */
							char d_name[256];			/* f파일 이름 */
						}
						==============================================================================================

				# readdir()을 연속 호출 --> 원하는 파일을 찾기
				# readdir()이 NULL을 반환할 때까지 전체 디렉터리 모두 읽으면서 개별 파일을 얻어올 수 있다.

		- 디렉터리 스트림 닫기
			$ opendir()로 연 디렉터리 스트림은 closedir()로 닫는다.
				==============================================================================================
				#include <sys/types.h>
				#include <dirent.h>

				int closedir(DIR *dir);
				==============================================================================================
				# 호출 성공: dir이 가리키는 디렉터리 스트림과 여기 포함된 파일 디스크립터를 닫고 0 반환.
				# 호출 실패: -1 반환, errno : EBADF 설정.

	(8.3) 링크
		- 링크: 디렉터리에서 이름과 inode를 맵핑하는 개념
		* 동일한 inode에 링크를 여러 개 걸 수 있다.
			예) 단일 inode는 /etc/customs과 /var/run/ledger 양쪽에서 참조될 수 있다.
				--> 위 두 디렉터리는 같은 파일시스템에 존재해야 한다. (링크는 inode와 맵핑되고 inode 번호는 특정 파일시스템에 연관되어 있으므로)
		* 같은 파일 시스템 내부에서만 특정 파일에 여러 링크를 걸 수 있다.
		* 같은 파일을 가리키는 모든 링크는 동등한 지위를 가짐.

		- 하드 링크(Hard Link)
			$ 파일은 0, 1 또는 여러 개의 링크를 가질 수 있다.

		- 커널은 링크 카운터와 사용 카운터를 이용하여 파일을 삭제한다
			$ 사용 카운터: 파일을 열고 있는 인스턴스의 개수를 센다
			$ 링크 카운터와 사용 카운터 모두 0이 되지 않는 한 파일세스템에서 파일은 삭제되지 않음.

		- 심벌릭 링크(Symbolic Link)
			$ 파일시스템 맵핑이 아닌 실행 중에 해석되는 링크(이런 링크는 파일시스템이 달라도 사용 가능)

	(8.3.1) 하드 링크(Hard Link)
		- 이미 존재하는 파일에 새로운 링크 생성
			==============================================================================================
			#include <unistd.h>

			int link(const char *oldpath, const char *newpath);
			==============================================================================================
			$ 호출 성공: 이미 존재하는 파일인 oldpath를 가리키는 newpath라는 링크를 생성하고 0 반환.
			$ 호출이 완료되면 oldpath와 newpath는 같은 파일을 가리킨다.
			* 어떤 링크가 '원본'인지 확인할 수 없다.
			$ 호출 실패: -1 반환, errno 설정

	(8.3.2) 심벌링 링크(Symbolic Link)
		- 소프트링크
		- 파일시스템에 존재하는 파일을 가리킨다는 점에서 하드 링크와 비슷
		- 추가적인 디렉터리 엔트리가 아닌 새로운 유형의 파일
			$ 이 특수 파일은 심벌릭 링크가 가리키는 다른 파일의 경로를 가짐
		- 실행 중에 동적으로 심벌릭 링크의 경로를 심벌릭 링크가 가리키는 대상으로 교체
		* 하드 링크는 같은 파일을 가리키는 다른 하드링크와 구분이 안되지만, 심벌릭 링크와 심벌릭 링크가 가리키는 파일은 쉽게 구분 가능.
		- 심벌릭 링크는 상대 경로나 절대 경로로 표현 가능.
		- . 디렉터리나 부모 디렉터리를 나타내는 .. 디렉터리도 포함 가능
		- 흔히 사용되지만 유용하진 않음.
		- 파일 시스템이 달라도 사용 가능(어떤 곳이라도 가리킬 수 있다)
		- 존재하는, 존재하지 않는 파일 모두 가리킬 수 있다.
			$ 존재하지 않는 파일을 가리키는 링크: Dangling Link(댕글링 링크)
				# 링크가 가리키는 대상이 삭제되었지만, 심벌릭 링크는 삭제하지 않아서 댕글링 링크가 생기는 경우 존재
				* 의도적으로 이런 상태를 만들기도 한다.
		- 함수
			==============================================================================================
			#include <unistd.h>

			int symlink(const char *oldpath, const char *newpath);
			==============================================================================================
			$ 호출 성공: oldpath를 가리키는 심벌릭 링크인 newpath를 생성하고 0을 반환
			$ 에러 발생: -1 반환, errno 설정

	(8.3.3) 링크 끊기
		- 파일시스템에서 경로 이름을 삭제한다.
			==============================================================================================
			#include <unistd.h>

			int unlink(const char *pathname);
			==============================================================================================
			$ 호출 성공: 파일 시스템에서 pathname을 삭제하고 0을 반환.
			$ 이름이 그 파일을 참조하는 최후의 대상이면 파일은 파일세스템에서 삭제한다.
			* 프로세스가 파일을 열고 있는 상태라면 커널은 해당 프로세스가 그 파일을 닫을 때까지 파일세스템에서 파일을 삭제하지 않음.
			* 열고 있는 프로세스가 없다면 그 파일은 삭제된다.
			* 디렉터리를 삭제하지 않는다. 디렉터리를 삭제하려면 rmdir()을 사용해야 함.

			* remove() 함수
				==============================================================================================
				#include <stdio.h>

				int remove(const char *path);
				==============================================================================================
				$ 파일 타입에 상관없이 과감하게 삭제 수행
				$ 호출 성공: path를 삭제하고 0을 반환
				$ path가 파일이라면 remove()는 unlink() 호출
				$ path가 디렉터리라면 remove()는 rmdir()을 호출
				$ 호출 실패: -1 반환, errno를 unlink()나 rmdir()에서 설정하는 값으로 설정.

	(8.4) 파일 복사와 이동
		- 복사: 완전히 독립적인 두 개의 파일이 서로 다른 디렉터리 엔트리로 존재하는 것
		- 이동: 파일이 위치한 디렉터리 엔트리의 이름을 바꾸는 것

	(8.4.1) 복사
		- 유닉스는 파일과 디렉터리를 복사하기 위한 시스템 콜이나 라이브러리를 제공하지 않는다.
		- src 파일을 dst로 복사하는 방법
			1. src 를 연다.
			2. dst를 연다. dst가 없으면 새로 생성, dst가 있으면 길이를 0으로 자름.
			3. src의 내용을 일부 메모리로 읽어온다.
			4. 메모리에 읽은 내용을 dst에 쓴다.
			5. src의 내용을 모두 읽어서 dst에 다 쓸 때까지 반복한다.
			6. dst를 닫는다.
			7. src를 닫는다.

			* 디렉터리를 복사하려면 개별 디렉터리와 하위 디렉터리를 모두 mkdir()로 생성한 다음 개별 파일을 디렉터리로 복사한다.

	(8.4.2) 이동
		- 복사와 달리, 이동을 위한 시스템 콜은 제공한다.
			==============================================================================================
			#include <stdio.h>

			int rename(const char *oldpath, const char *newpath);
			==============================================================================================
			$ 호출 성공: oldpath를 newpath로 바꾼다(참조 변경), 0 반환.
			$ 호출 실패: -1 반환, oldpath나 newpath를 건드리지 않으며 errno 설정.
			* 파일의 내용과 inode는 그대로 유지된다.
			* oldpath와 newpath는 같은 파일시스템에 존재해야 한다.

	(8.5) 디바이스 노드
		- 앱과 디바이스 드라이버를 연결하는 인터페이스를 제공하는 특수한 파일
		- 커널은 디바이스 노드 대상으로 읽기, 쓰기, 열기, 닫기와 같은 일반적인 유닉스 입출력 요청을 디바이스 드라이버로 전달한다.
			--> 디바이스 드라이버는 이런 연산을 처리한 다음 결과를 사용자에게 반환한다.
		- 디바이스 노드: 유닉스 시스템에서 하드웨어에 접근하는 표준 메커니즘.
			$ 하드웨어를 read(), write(), mmap() 호출을 통해 다루는 방식은 명쾌한 방식

		- 디바이스 노드는 두 가지 숫자가 매겨진다.
			$ 메이저 번호와 마이너 번호는 커널에 적재된 특정 디바이스 드라이버와 맵핑된다.
				# 메이저 번호
				# 마이너 번호

	(8.5.1) 특수 디바이스 노드
		- null 디바이스: 메이저 번호가 1, 마이너 번호가 3이며 /dev/null에 위치
			# 이 파일은 root가 소유, 모든 사용자가 read, write 가능해야 함.
			* 커널은 이 디바이스에 들어오는 모든 쓰기 요청을 무시, 읽기 요청에는 EOF 반환.
		
		- zero 디바이스: 메이저 번호가 1, 마이너 번호가 5이며 /dev/zero에 위치
			* 커널은 이 디바이스에 들어오는 모든 쓰기 요청을 무시, 읽기 요청에는 무한한 null 바이트 스트림을 반환.
		
		- full 디바이스: 메이저 번호가 1, 마이너 번호가 7이며, /dev/full에 위치
			* 커널은 읽기 요청에는 null 문자(\0)를 반환
			* 쓰기 요청에는 항상 디바이스가 가득 찬 상태를 나타내는 ENOSPC 에러 반환.

		* 사용 목적
			예) full 디바이스: 파일시스템이 가득 찬 상황에서 앱이 어떻게 동작하는지 테스트할 때 유용
			예) null, zero 디바이스: 쓰기를 무시하므로 원치 않는 입출력을 말끔히 처리 가능.

	(8.5.2) 난수 발생기
		- /dev/random과 /dev/urandom에 위치
		- 메이저 번호 1, 마이너 번호는 각각 8, 9
		
		- /dev/random 파일을 읽으면, 엔트로피 풀에서 엔트로피를 반환, 결과는 난수 발생기에 사용할 시드 값을 쓰거나, 키 생성을 수행, 아니면 암호학적인 측면에서 강한 엔트로피가 필요한 작업을 수행하는 데 유용함.

		- /dev/urandom 파일 읽기 요청 성공.
			* 대부분의 앱은 강한 엔트로피를 필요로 하지 않으므로 /dev/urandom을 사용

	(8.6) 대역 외 통신
		- ioctl() 시스템 콜 사용
			$ 대역폭 외(OOB: Out Of Band) 통신 허용.
				==============================================================================================
				#include <sys/ioctl.h>

				int ioctl(int fd, int request, ...);
				==============================================================================================
				# fd: 파일 디스크립터
				# request: 특수한 요청 코드 값, fd가 참조하는 파일에 대해 수행 가능한 연산이 무엇인지 커널과 프로세스에 의해 미리 정의.

	(8.7) 파일 이벤트 모니터링
		- inotify: 파일이 옮겨지거나 읽히거나 쓰여지거나 삭제되는 등의 이벤트 모니터링 할 수 있는 인터페이스
		- 커널은 이벤트가 발생했음을 앱에 알려줄 수 있다.
			예) 파일이 삭제되면 커널은 파일이 삭제됨을 파일 매니저에 통지하고, 파일 매니저는 즉시 삭제된 파일을 디렉터리 화면에서 제거할 수 있다.

	(8.7.1) inotify 초기화하기
		- 사용하기 전 반드시 초기화부터 해야 한다.
			==============================================================================================
			#include <sys/inotify.h>

			int inotify_init1(int flags);
			==============================================================================================
			$ flags: 보통 0으로 쓰지만 다음 플래그 OR로 묶어 사용 가능
				# IN_CLOEXEC
				# IN_NONBLOCK
				# EMFILE
				# ENFILE
				# ENOMEM

	(8.7.2) 감시
		- 초기화 후 감시를 설정
		- 감시는 감시 디스크립터로 표현되며 감시 마스크(읽기, 쓰기, 또는 둘 다)로 구성되어 있음.
		- inotify는 파일과 디렉터리 모두 감시 가능.
		- 새로운 감시 등록하기
			==============================================================================================
			#include <sys/inotify.h>

			int inotify_add_watch(int fd, const char *path, uint32_t mask);
			==============================================================================================
			$ 호출 성공: 새로운 감시 디스크립터 반환
			$ 호출 실패: -1 반환, errno 설정
			$ 감시 마스크
				# IN_ACCESS
				# IN_MODIFY
				# IN_ATTRIB
				# IN_CLOSE_WRITE
				# IN_CLOSE_NOWRITE
				# IN_OPEN
				# IN_MOVED_FROM
				# IN_MOVED_TO
				# IN_CREATE
				# IN_DELETE
				# IN_DELETE_SELF
				# IN_MOVE_SELF

				* 둘 이상의 이벤트를 묵어놓은 마스크
					@ IN_ALL_EVENTS
					@ IN_CLOSE
					@ IN_MOVE

	(8.7.3) inotify 이벤트
		- inotify_event 구조체(<inotify.h>에 정의되어 있으며 inotify 이벤트 나타냄)
			==============================================================================================
			#include <sys/inotify.h>

			struct inotify_event{
				int wd;				/* 감시 디스크립터 */
				uint32_t mask;		/* 이벤트 마스크 */
				uint32_t cookie;	/* 유일한 쿠키 */
				uint32_t len;		/* 'name' 필드의 크기 */
				char name[];		/* null로 끝나는 이름 */
			}
			==============================================================================================
			* name: 길이가 0인 배열의 한 예(유연한 배열: C99 포준에서 제공하는 기능으로 생성한 가변 길이의 배열)
			$ cookie: 분리된 두가지 이벤트를 하나로 연결하기 위해 사용.

		- inotify 이벤트 읽기
			$ read()에 전달한 버퍼에 담을 수 있는만큼 한 번에 여러 이벤트를 읽을 수 있는 기능 제공.
				--> 가변 길이의 name 필드 때문에 inotify 이벤트를 읽는 가장 보편적 방법
			$ inotify 파일 디스크립터는 일반 파일처럼 동작함.
				--> select, poll, epoll을 사용해서 모니터링 가능. --> 싱글스레드에서 inotify 이벤트와 다른 파일 입출력을 다중화 할 수 있다.

		- 고급 inotify 이벤트
			$ IN_IGNORED
			$ IN_ISDIR
			$ IN_Q_OVERFLOW
			$ IN_UMOUNT

			* mask를 대기 중인 이벤트의 비트마스크로 취급해야 하므로 ==이 아닌 &를 사용해서 이벤트를 비교해야 한다.

		- 이동 이벤트를 하나로 연결하기
			$ IN_MOVED_FROM과 IN_MOVED_TO는 각각 이동 상태의 한쪽 상태만 나타냄
				# IN_MOVED_FROM: 주어진 위치에서 삭제가 일어남을 나타낸다.
				# IN_MOVED_TO: 새로운 위치에 추가됨을 나타낸다.

			$ cookie 필드는 0이 아닐 때 두 이벤트를 하나로 연결하는 유일한 값을 가지고 있다.

	(8.7.4) 고급 감시 옵션
		- 새로운 감시 생성 시, 감시 동작 제어를 위해 하나 이상을 mask에 추가할 수 있음
			$ IN_DONT_FOLLOW
			$ IN_MASK_ADD
			$ IN_ONESHOT
			$ IN_ONLYDIR

	(8.7.5) inotify 감시 삭제하기
		- inotify_rm_watch() 시스템 콜을 사용해서 inotify 인스턴스에서 감시 삭제 가능.
			==============================================================================================
			#include <inotify.h>

			int inotify_rm_watch(int fd, uint32_t wd);
			==============================================================================================
			$ 호출 성공: fd가 가리키는 inotify 인스턴스에서 감시 디스크립터 wd가 가리키는 감시를 제거하고 0 반환
			$ 호출 실패: -1 반환, errno 설정

		- 감시 삭제 시 커널은 IN_IGNORED 이벤트를 발생(wd가 가리키는 감시 제거)

	(8.7.6) 이벤트 큐 크기 구하기
		- 이벤트 큐의 크기: ioctl()을 통해 inotify 인스턴스의 파일 디스크립터에 FIONREAD 명령을 보내서 얻을 수 있다.

	(8.7.7) inotify 인스턴스 끝내기
		- 간단히 인스턴스의 파일 디스크립터를 다으면 된다.(close(fd);)
		- 물론, 프로세스가 종료되면 커널이 자동으로 파일 디스크립터를 닫고 리소스를 정리한다.














