[프로세스 관리]
1) 프로그램, 프로세스, 스레드
	- 바이너리
		> 디스크 같은 저장장치에 기록되어 있는 컴파일된, 실행할 수 있는 코드
		> 프로그램, 때로는 애플리케이션
	- 프로세스
		> 실행 중인 프로그램.
		> 메모리에 적재된 바이너리 이미지, 가상화된 메모리의 인스턴스, 열린 파일 같은 커널 리소스, 관련된 사용자 정보와 같은 보안 정보, 하나 이상의 스레드 포함.
			$ 스레드: 프로세스 내 실행 단위(스택, 레지스터, 명령어 포인터 같은 프로세서의 상태 포함)
		> 싱글 스레드 프로세스는 프로세스가 곧 스레드.
			$ 가상화된 메모리 인스턴스 하나와 가상 프로세서 하나가 존재.
		> 멀티 스레드 프로세스
			$ 스레드 여러개 존재
			$ 프로세스와 관련된 가상 메모리는 모든 스레드가 같은 주소 공간을 공유.

2) 프로세스 ID
	- PID(프로세스 ID)
		> 유일한 식별자(모든 프로세스는 pid로 구분)
		> 유일한 값 보장
		> 동작 중인 다른 프로세스가 없을 때 커널이 실행하는 idle 프로세스는 pid가 0
		> 부팅 후 커널이 실행하는 최초 프로세스인 init 프로세스의 pid는 1

		> 사용자가 어떤 프로세스를 실행하라고 명시적으로 요청하지 않으면 커널은 독자적으로 적절한 init 프로세스 확인
			<순서 - 가장 먼저 찾은 프로세스를 init 프로세스로 실행>
			1. /sbin/init: 가장 먼저 찾는 init 프로세스
			2. /etc/init: 두 번째로 찾는 init 프로세스
			3. /bin/init: 우선 탐색에 실패했을 때 찾는 init 프로세스
			4. /bin/sh: 커널이 앞의 순서대로 init 프로세스를 찾는 데 실패한 뒤에 실행하는 본셸의 위치
				* 본셸(bourne shell.bsh)

			* 실행 실패 시: '커널 패닉'을 일으키며 시스템을 중단
				* 커널 패닉: 윈도우즈의 블루스크린과 동일한 것으로 간주.

	- 프로세스 ID 할당
		> 보통 커널의 최대 pid 값: 32768(2^15) 
			* 32768: 부호형signed 16비트 정수를 사용했던 오래된 유닉스 시스템과의 호환성을 위함
			* 지금은 4194304: (2^22) 커널이 22bit range 허용.(예전엔 16비트)
			> 32비트: 32768, 64비트: 4194304
		> /proc/sys/kerner/pid_max 값을 수정하여 사용 가능.(단 호환성 일부 포기)
		> 앞선 pid 값이 비어 있더라도 재사용되지 않는다.

	- 프로세스 계층
		> 부모 프로세스: 새로운 프로세스를 생성하는(Spawn) 프로세스
		> 자식 프로세스: 새롭게 생성된 프로세스(관계는 프로세스의 부모 프로세스(ppid)를 보면 확인 가능)

		> 모든 프로세스는 사용자와 그룹이 소유한다(단순한 정수 값).
			$ 소유: 리소스에 대한 접근 권한 제어하기 위함
			$ 모든 자식은 부모 프로세스의 사용자와 그룹 권한을 상속받는다.

		> 모든 프로세스는 다른 프로세스와의 관계를 표현하고 있는 프로세스 그룹의 일부
			$ 자식 프로세스는 보통 부모 프로세스의 프로세스 그룹에 속하게 된다.

	- pid_t
		> 프로그램에서 pid는 pid_t 자료형으로 표현 (<sys/types.h> 헤더 파일에 정의됨)

	- 프로세스 ID와 부모 프로세스 ID 얻기
		> getpid() 시스템 콜: 호출한 프로세스의 pid를 반환
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getpid(void);
			========================================================================

		> getppid() 시스템 콜: 호출한 프로세스의 부모 프로세스의 pid를 호출
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getppid(void);
			========================================================================

		* 두 시스템 콜은 에러를 반환하지 않는다.

3) 새로운 프로세스 실행하기
	- 실행(exec): 프로그램 바이너리를 메모리에 적재하고 프로세스의 주소 공간에 있는 이전 내용을 대체한 다음, 새로운 프로그램의 실행을 시작
	- 포크(fork): 부모 프로세스를 거의 그대로 복제하여 새로운 프로세스를 생성, 대게 새로운 프로세스는 즉시 새 프로그램을 실행.

	- 새로운 프로그램 실행
		1. 새로운 프로세스를 포크(fork)
		2. 생성된 프로세스에 새로운 바이너리를 적재하여 실행하는 과정 필요.

	- exec 함수들
		> execl() 시스템 콜
			========================================================================
			#include <unistd.h>

			int execl(const char *path, const char *arg, ...);
			========================================================================
			$ 현재 프로세스를 path가 가리키는 프로그램으로 대체
			$ ...는 가변 인자로, 반드시 NULL로 끝나야 함.

			(예제)
			========================================================================
			int ret;
			ret = execl("/bin/vi", "vi", NULL);
			if(ret==-1)
				perror("execl");
			========================================================================
			$ path인 "/bin/vi"의 마지막 요소, vi를 첫 번째 인자로 두어, 프로세스의 fork()/exec 과정에서 argv[0]을 검사하여 바이너리 이미지의 이름 검색

			(예제)
			========================================================================
			int ret;
			ret = execl("/bin/vi", "vi", "/home/kidd/hooks.txt", NULL);
			if(ret == -1)
				perror("execl");
			========================================================================
			$ vi 편집기를 사용해서 hooks.txt 파일을 편집.

		> 일반적으로 execl()은 반환값이 없다.
			$ 성공
				# 새로운 프로그램의 시작점으로 건너뛰며 이전에 실행했던 코드는 그 프로세스의 주소 공간에 더 이상 존재하지 않음. 
				# 프로세스의 주소 공간과 프로세스 이미지뿐만 아니라, 다음과 같이 프로세스의 다른 속성들도 변경
					@ 대기 중인 시그널 사라짐
					@ 프로세스가 받은 시그널은 디폴트 방식으로 처리됨
					@ 메모리 락이 해제됨
					@ 스레드의 속성 대부분이 기본값으로 돌아감
					@ 프로세스의 통계 대부분이 재설정됨
					@ 메모리에 맵핑된 파일을 포함하여 그 프로세스의 메모리 주소 공간과 관련된 모든 내용이 사라짐
					@ C 라이브러리의 기능 atexit() 내용처럼 사용자 영역에만 존재하는 모든 내용이 사라짐

				* 하지만, pid, ppid, 우선순위, 소유자와 그룹처럼 변경되지 않는 속성도 존재.
				
		> 에러: -1, errno 설정

		* exec 호출 과정에서 열린 파일은 그대로 상속된다.
			$ 새롭게 실행되는 프로그램이 fd 값을 알고 있으면 원래 프로세스에서 열었던 모든 파일에 접근이 가능
				--> exec 호출 전 파일을 모두 close() 해라
				--> fcntl()을 통해서 커널이 이 과정을 자동적으로 수행하도록 지시 가능.

		> 다른 exec 함수들
			$ execlp
				========================================================================
				#include <unistd.h>

				int execlp(const char *file, const char *arg, ...);
				========================================================================
				# execl + p
				# p는 file 인자 값을 사용자의 실행 경로 환경 변수에서 찾게 됨

			$ execle
				========================================================================
				#include <unistd.h>

				int execle(const char *path, const char *arg, ..., char * const envp[]);
				========================================================================
				# execl + e
				# 새롭게 생성될 프로세스를 위한 새로운 환경을 제공

			(예제)
			========================================================================
			int ret;
			ret = execvp("vi", "vi", "/home/kidd/hooks.txt", NULL);
			if(ret == -1)
				perror("execl");
			========================================================================	
			$ 사용자의 실행 경로에서 vi 실행 프로그램을 찾는다.

			(execlp()와 execvp() 함수의 보안 위험)
			* 실행 파일의 사용자나 그룹으로 실행되는 프로세스인 SGID와 SUID 프로그램은 절대로 직접 셸을 실행하거나 셸을 실행하는 작업을 해서는 안된다.
				--> 그 작업을 실행하는 사용자가 환경 변수를 변경하여 셸의 동작을 조작할 수 있는 보안상의 문제 발생.
				--> 가로채기(Path Injection): execlp()가 원하는 바이너리를 실행하도록 PATH 변수를 변경하여 해당 바이너리의 SGID 혹은 SUID 권한으로 프로그램을 실행
				# SGID: Set Group ID
				# SUID: Set User ID

			$ execv
				========================================================================
				const char *args[] = {"vi", "/home/kidd/hooks.txt", NULL};
				int ret;

				ret = execv("/bin/vi", args);
				if(ret==-1)
					perror("execv");
				========================================================================
				$ 위는 인자를 args 배열로 받으며 기본 인자로 받는 함수와 동작은 동일.
				$ 배열을 사용: 필요한 인자를 실행 시간(RunTime)에 동적으로 결정할 수 있다는 장점.

			$ execve
				========================================================================
				#include <unistd.h>

				int execve(const char *filename, char *const argv[], char *const envp[]);
				========================================================================
				# 시스템 콜로 존재하는 함수(나머지는 wrapper 함수)
				# 사용자 함수와 동일.
				* 가변 인자를 쓰는 시스템 콜은 구현하기 어렵고 실행 경로라는 개념은 사용자 공간에서만 존재

	- fork() 시스템 콜
		> 현재 실행 중인 프로세스와 동일한 프로세스 새롭게 실행 가능.
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t fork(void);
			========================================================================
			$ 호출 성공: fork()를 실행한 프로세스와 거의 모든 내용이 동일한 새로운 프로세스를 생성.
				# 두 프로세스는 계속 실행 상태, fork()로 새롭게 생성된 프로세스는 아무 일도 없었던 것처럼 계속 실행.
				# 부모(원래 프로세스) <--> 자식(새롭게 생성된 프로세스)
				# 부모: 반환값 자식 프로세스의 pid
				# 자식: 반환값 0

				# 필수 항목
					* 자식 프로세스의 pid는 부모 프로세스와 다른 값으로 할당
					* 자식 프로세스의 ppid는 부모 프로세스의 pid
					* 자식 프로세스에서 리소스 통계는 0으로 초기화
					* 처리되지 않은 시그널은 모두 사라지고 자식 프로레스로 상속되지 않음
					* 부모의 파일 락은 자식으로 상속되지 않음.

			$ 호출 실패: -1 반환, errno 설정(자식 프로세스 생서되지 않음)

			(예제)
			========================================================================
			pid_t pid;

			pid = fork();
			if(pid>0)
				printf("I am the parent of pid=%d\n", pid);
			else if(!pid)
				printf("I am the child!\n");
			else if(pid == -1)
				perror("fork");
			========================================================================

		> 흔한 사례는 새로운 프로세스를 생성하고 그 후에 새 프로세스에 새로운 바이너리 이미지를 올리는 것.
		> fork() + exec
			$ 어떤 프로세스에서 새로운 프로세스를 생성하고 자식 프로세스에서 새로운 바이너리 이미지를 실행

			(예제)
			========================================================================
			pid_t pid;
			pid = fork();
			if(pid == -1)
				perror("fork");

			/* 자식 프로세스 */
			if(!pid){
				const char *args[] = {"windlass", NULL};
				int ret;

				ret = execv("/bin/windlass", args);
				if(ret == -1){
					perror("execv");
					exit(EXIT_FAILURE);
				}
			}
			========================================================================
			$ 새로운 프로세스를 생성하고 /bin/windlass 바이너리를 실행.















