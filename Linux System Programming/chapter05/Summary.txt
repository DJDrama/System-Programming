[프로세스 관리]
1) 프로그램, 프로세스, 스레드
	- 바이너리
		> 디스크 같은 저장장치에 기록되어 있는 컴파일된, 실행할 수 있는 코드
		> 프로그램, 때로는 애플리케이션
	- 프로세스
		> 실행 중인 프로그램.
		> 메모리에 적재된 바이너리 이미지, 가상화된 메모리의 인스턴스, 열린 파일 같은 커널 리소스, 관련된 사용자 정보와 같은 보안 정보, 하나 이상의 스레드 포함.
			$ 스레드: 프로세스 내 실행 단위(스택, 레지스터, 명령어 포인터 같은 프로세서의 상태 포함)
		> 싱글 스레드 프로세스는 프로세스가 곧 스레드.
			$ 가상화된 메모리 인스턴스 하나와 가상 프로세서 하나가 존재.
		> 멀티 스레드 프로세스
			$ 스레드 여러개 존재
			$ 프로세스와 관련된 가상 메모리는 모든 스레드가 같은 주소 공간을 공유.

2) 프로세스 ID
	- PID(프로세스 ID)
		> 유일한 식별자(모든 프로세스는 pid로 구분)
		> 유일한 값 보장
		> 동작 중인 다른 프로세스가 없을 때 커널이 실행하는 idle 프로세스는 pid가 0
		> 부팅 후 커널이 실행하는 최초 프로세스인 init 프로세스의 pid는 1

		> 사용자가 어떤 프로세스를 실행하라고 명시적으로 요청하지 않으면 커널은 독자적으로 적절한 init 프로세스 확인
			<순서 - 가장 먼저 찾은 프로세스를 init 프로세스로 실행>
			1. /sbin/init: 가장 먼저 찾는 init 프로세스
			2. /etc/init: 두 번째로 찾는 init 프로세스
			3. /bin/init: 우선 탐색에 실패했을 때 찾는 init 프로세스
			4. /bin/sh: 커널이 앞의 순서대로 init 프로세스를 찾는 데 실패한 뒤에 실행하는 본셸의 위치
				* 본셸(bourne shell.bsh)

			* 실행 실패 시: '커널 패닉'을 일으키며 시스템을 중단
				* 커널 패닉: 윈도우즈의 블루스크린과 동일한 것으로 간주.

	- 프로세스 ID 할당
		> 보통 커널의 최대 pid 값: 32768(2^15) 
			* 32768: 부호형signed 16비트 정수를 사용했던 오래된 유닉스 시스템과의 호환성을 위함
			* 지금은 4194304: (2^22) 커널이 22bit range 허용.(예전엔 16비트)
			> 32비트: 32768, 64비트: 4194304
		> /proc/sys/kerner/pid_max 값을 수정하여 사용 가능.(단 호환성 일부 포기)
		> 앞선 pid 값이 비어 있더라도 재사용되지 않는다.

	- 프로세스 계층
		> 부모 프로세스: 새로운 프로세스를 생성하는(Spawn) 프로세스
		> 자식 프로세스: 새롭게 생성된 프로세스(관계는 프로세스의 부모 프로세스(ppid)를 보면 확인 가능)

		> 모든 프로세스는 사용자와 그룹이 소유한다(단순한 정수 값).
			$ 소유: 리소스에 대한 접근 권한 제어하기 위함
			$ 모든 자식은 부모 프로세스의 사용자와 그룹 권한을 상속받는다.

		> 모든 프로세스는 다른 프로세스와의 관계를 표현하고 있는 프로세스 그룹의 일부
			$ 자식 프로세스는 보통 부모 프로세스의 프로세스 그룹에 속하게 된다.

	- pid_t
		> 프로그램에서 pid는 pid_t 자료형으로 표현 (<sys/types.h> 헤더 파일에 정의됨)

	- 프로세스 ID와 부모 프로세스 ID 얻기
		> getpid() 시스템 콜: 호출한 프로세스의 pid를 반환
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getpid(void);
			========================================================================

		> getppid() 시스템 콜: 호출한 프로세스의 부모 프로세스의 pid를 호출
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getppid(void);
			========================================================================

		* 두 시스템 콜은 에러를 반환하지 않는다.

3) 새로운 프로세스 실행하기
	- 실행(exec): 프로그램 바이너리를 메모리에 적재하고 프로세스의 주소 공간에 있는 이전 내용을 대체한 다음, 새로운 프로그램의 실행을 시작
	- 포크(fork): 부모 프로세스를 거의 그대로 복제하여 새로운 프로세스를 생성, 대게 새로운 프로세스는 즉시 새 프로그램을 실행.

	- 새로운 프로그램 실행
		1. 새로운 프로세스를 포크(fork)
		2. 생성된 프로세스에 새로운 바이너리를 적재하여 실행하는 과정 필요.

	- exec 함수들
		> execl() 시스템 콜
			========================================================================
			#include <unistd.h>

			int execl(const char *path, const char *arg, ...);
			========================================================================
			$ 현재 프로세스를 path가 가리키는 프로그램으로 대체
			$ ...는 가변 인자로, 반드시 NULL로 끝나야 함.

			(예제)
			========================================================================
			int ret;
			ret = execl("/bin/vi", "vi", NULL);
			if(ret==-1)
				perror("execl");
			========================================================================
			$ path인 "/bin/vi"의 마지막 요소, vi를 첫 번째 인자로 두어, 프로세스의 fork()/exec 과정에서 argv[0]을 검사하여 바이너리 이미지의 이름 검색

			(예제)
			========================================================================
			int ret;
			ret = execl("/bin/vi", "vi", "/home/kidd/hooks.txt", NULL);
			if(ret == -1)
				perror("execl");
			========================================================================
			$ vi 편집기를 사용해서 hooks.txt 파일을 편집.

		> 일반적으로 execl()은 반환값이 없다.
			$ 성공
				# 새로운 프로그램의 시작점으로 건너뛰며 이전에 실행했던 코드는 그 프로세스의 주소 공간에 더 이상 존재하지 않음. 
				# 프로세스의 주소 공간과 프로세스 이미지뿐만 아니라, 다음과 같이 프로세스의 다른 속성들도 변경
					@ 대기 중인 시그널 사라짐
					@ 프로세스가 받은 시그널은 디폴트 방식으로 처리됨
					@ 메모리 락이 해제됨
					@ 스레드의 속성 대부분이 기본값으로 돌아감
					@ 프로세스의 통계 대부분이 재설정됨
					@ 메모리에 맵핑된 파일을 포함하여 그 프로세스의 메모리 주소 공간과 관련된 모든 내용이 사라짐
					@ C 라이브러리의 기능 atexit() 내용처럼 사용자 영역에만 존재하는 모든 내용이 사라짐

				* 하지만, pid, ppid, 우선순위, 소유자와 그룹처럼 변경되지 않는 속성도 존재.
				
		> 에러: -1, errno 설정

		* exec 호출 과정에서 열린 파일은 그대로 상속된다.
			$ 새롭게 실행되는 프로그램이 fd 값을 알고 있으면 원래 프로세스에서 열었던 모든 파일에 접근이 가능
				--> exec 호출 전 파일을 모두 close() 해라
				--> fcntl()을 통해서 커널이 이 과정을 자동적으로 수행하도록 지시 가능.

		> 다른 exec 함수들
			$ execlp
				========================================================================
				#include <unistd.h>

				int execlp(const char *file, const char *arg, ...);
				========================================================================
				# execl + p
				# p는 file 인자 값을 사용자의 실행 경로 환경 변수에서 찾게 됨

			$ execle
				========================================================================
				#include <unistd.h>

				int execle(const char *path, const char *arg, ..., char * const envp[]);
				========================================================================
				# execl + e
				# 새롭게 생성될 프로세스를 위한 새로운 환경을 제공

			(예제)
			========================================================================
			int ret;
			ret = execvp("vi", "vi", "/home/kidd/hooks.txt", NULL);
			if(ret == -1)
				perror("execl");
			========================================================================	
			$ 사용자의 실행 경로에서 vi 실행 프로그램을 찾는다.

			(execlp()와 execvp() 함수의 보안 위험)
			* 실행 파일의 사용자나 그룹으로 실행되는 프로세스인 SGID와 SUID 프로그램은 절대로 직접 셸을 실행하거나 셸을 실행하는 작업을 해서는 안된다.
				--> 그 작업을 실행하는 사용자가 환경 변수를 변경하여 셸의 동작을 조작할 수 있는 보안상의 문제 발생.
				--> 가로채기(Path Injection): execlp()가 원하는 바이너리를 실행하도록 PATH 변수를 변경하여 해당 바이너리의 SGID 혹은 SUID 권한으로 프로그램을 실행
				# SGID: Set Group ID
				# SUID: Set User ID

			$ execv
				========================================================================
				const char *args[] = {"vi", "/home/kidd/hooks.txt", NULL};
				int ret;

				ret = execv("/bin/vi", args);
				if(ret==-1)
					perror("execv");
				========================================================================
				$ 위는 인자를 args 배열로 받으며 기본 인자로 받는 함수와 동작은 동일.
				$ 배열을 사용: 필요한 인자를 실행 시간(RunTime)에 동적으로 결정할 수 있다는 장점.

			$ execve
				========================================================================
				#include <unistd.h>

				int execve(const char *filename, char *const argv[], char *const envp[]);
				========================================================================
				# 시스템 콜로 존재하는 함수(나머지는 wrapper 함수)
				# 사용자 함수와 동일.
				* 가변 인자를 쓰는 시스템 콜은 구현하기 어렵고 실행 경로라는 개념은 사용자 공간에서만 존재

	- fork() 시스템 콜
		> 현재 실행 중인 프로세스와 동일한 프로세스 새롭게 실행 가능.
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t fork(void);
			========================================================================
			$ 호출 성공: fork()를 실행한 프로세스와 거의 모든 내용이 동일한 새로운 프로세스를 생성.
				# 두 프로세스는 계속 실행 상태, fork()로 새롭게 생성된 프로세스는 아무 일도 없었던 것처럼 계속 실행.
				# 부모(원래 프로세스) <--> 자식(새롭게 생성된 프로세스)
				# 부모: 반환값 자식 프로세스의 pid
				# 자식: 반환값 0

				# 필수 항목
					* 자식 프로세스의 pid는 부모 프로세스와 다른 값으로 할당
					* 자식 프로세스의 ppid는 부모 프로세스의 pid
					* 자식 프로세스에서 리소스 통계는 0으로 초기화
					* 처리되지 않은 시그널은 모두 사라지고 자식 프로레스로 상속되지 않음
					* 부모의 파일 락은 자식으로 상속되지 않음.

			$ 호출 실패: -1 반환, errno 설정(자식 프로세스 생서되지 않음)

			(예제)
			========================================================================
			pid_t pid;

			pid = fork();
			if(pid>0)
				printf("I am the parent of pid=%d\n", pid);
			else if(!pid)
				printf("I am the child!\n");
			else if(pid == -1)
				perror("fork");
			========================================================================

		> 흔한 사례는 새로운 프로세스를 생성하고 그 후에 새 프로세스에 새로운 바이너리 이미지를 올리는 것.
		> fork() + exec
			$ 어떤 프로세스에서 새로운 프로세스를 생성하고 자식 프로세스에서 새로운 바이너리 이미지를 실행

			(예제)
			========================================================================
			pid_t pid;
			pid = fork();
			if(pid == -1)
				perror("fork");

			/* 자식 프로세스 */
			if(!pid){
				const char *args[] = {"windlass", NULL};
				int ret;

				ret = execv("/bin/windlass", args);
				if(ret == -1){
					perror("execv");
					exit(EXIT_FAILURE);
				}
			}
			========================================================================
			$ 새로운 프로세스를 생성하고 /bin/windlass 바이너리를 실행.

		> copy-on-write
			$ fork() 호출 시
				1. 커널은 모든 내부 데이터 구조의 복사본을 생성
				2. 프로세스의 페이지 테이블 항목을 복제
				3. 페이지 단위로 부모 프로세스의 주소 공간의 복사본을 자식 프로레스의 새로운 주소 공간으로 복사

			$ 리눅스, 최신 유닉스에서는...
				# 부모 프로세스 주소 공간을 모두 복사하는 게 아닌 페이지에 대한 copy-on-write 수행.

			$ 복사에 의한 부하를 완화하기 위한 일종의 지연 최적화(lazy optimization) 기법
			$ 쓰기 작업을 할 경우에만 복사가 일어나기 때문에 copy-on-write
				# 단순히 리소스에 대한 포인터만 넘겨 받음
				# 변경 시도시, 해당 리소스는 복사되고 그 복사본을 변경 요청한 츠게 전달.
				# 다른 곳에서는 여전히 변경되지 않은 원본을 공유.
				# 변경 요청한 측에서는 복사본에 대해서 변경 수행 가능.

				(장점)
				1. 리소스의 복사본에 대한 변경이 필요 없을 때는 복사가 발생하지 않음.
				2. 필요한 시점까지 비용이 높은 연산을 미루는 일반적인 지연 알고리즘의 장점 취함.

			$ 페이지 기반으로 구현된다.
				# 부모와 자식 프로세스는 원본 페이지를 공유하고 있으며 공유하고 있는 페이지 역시 다른 부모나 자식 프로세스와 함께 공유하고 있다.

	- vfork()
		$ copy-on-write 도입 전 fork() 직후 exec가 이어지면 쓸모없는 주소 공간을 복사한다는 점을 해결하기 위해 개발

		========================================================================
		#include <sys/types.h>
		#include <unistd.h>

		pid_t vfork(void);
		========================================================================
		$ 자식 프로세스가 종료되든가 새로운 바이너리 이미지를 실행할 때까지 부모 프로세스를 잠시 멈춰두어 프로세스 주소 공간과 페이지 테이블 복사를 회피.

		$ 하는 일: 커널 내부 자료 구조를 복사 --> 자식 프로세스는 주소 공간 내의 어떤 메모리도 변경하면 안된다.

		* copy-on-write의 등장으로 vfork()는 장점이 없어짐.

4) 프로세스 종료하기
	- 종료 함수
		========================================================================
		#include <stdlib.h>

		void exit(int status);
		========================================================================
		$ 반환값이나 에러를 확인할 방법이 없음.

		$ EXIT_SUCCESS, EXIT_FAILURE
			========================================================================
			exit(EXIT_SUCCESS);
			========================================================================
			# 성공: 0
			# 실패: 1이나 -1처럼 0이 아닌 값

		$ 프로세스 종료 순서
			1. atexit()나 on_exit()에 등록된 함수가 있다면 등록 순서의 역순으로 호출.
			2. 열려 있는 모든 포준 입출력 스트림의 버퍼를 비운다.
			3. tmpfile() 함수를 통해 생성한 임시 파일 삭제.
			* 이 과정은 프로세스가 사용자 영역에서 해야 하는 모든 작업을 종료.
			* 그리고 exit()는 _exit() 시스템 콜을 실행해서 프로세스 종료의 나머지 단계를 커널이 처리하게 한다.
				========================================================================
				#include <unistd.h>

				void _exit(int status);
				========================================================================
				# 프로세스가 종료되면 커널은 해당 프로세스가 생성한 더 사용되지 않는 모든 리소스를 정리
					(할당된 메모리, 열린 파일, 시스템 V 세마포어)
					--> 이 모든 작업이 끝나면, 커널은 프로세스를 종료하고 자식 프로세스가 종료 됨을 부모에게 알려준다.

				* 앱에서 _exit()를 직접 호출하는 경우는 거의 없음.
				* 직접 사용할 경우, 앱은 표준 출력 스트림을 지우는 등의 사후 처리를 직접 해야함.
				(단, vfork() 사용시 _exit()를 exit() 대신에 사용해야 함)

	- 프로세스를 종료하는 다른 방법들
		> exit() 사용
		> main() 함수에서 반환값을 지정하여 명시적으로 종료 상태 반환
		> 프로세스를 종료시키는 시그널인 SIGTERM과 SIGKILL을 보내서 프로세스 종료
		
		(예외적 방법)
		> 커널은 잘못된 연산을 수행한다든가,
		> 세그멘테이션 폴트를 일으키거나,
		> 메모리를 고갈시키거나,
		> 허용된 것보다 더 많은 리소스를 소모할 경우
		--> 프로세스를 강제로 죽이기도 한다.

	- atexit()
		> 프로세스가 종료될 때 실행할 함수를 등록하기 위한 용도로 사용된다.
		========================================================================
		#include <stdlib.h>

		int atexit(void (*function)(void));
		========================================================================
		> 성공: 0
		> 에러: -1
		> exit() 혹은 main() 함수에서 return문에 도달해서 프로세스가 정상적으로 종료될 때 호출할 함수를 등록.
		* 시그널에 의해 프로세스가 종료되면 등록된 함수는 호출되지 않음.
		* 등록할 함수는 다음과 같은 아무런 인자도 없고 값도 반환하지 않는 함수여야 한다.
			========================================================================
			void my_function(void); // 반환값 void, 인자 void
			========================================================================

		> 등록된 함수는 등록된 순서의 역순으로 호출됨(스택에 저장되며 LIFO로 실행됨)
		> ATEXIT_MAX 만큼의 함수를 등록할 수 있도록 정하고 있으며 값은 32 이상.
			$ 정확한 값: sysconf() 함수에서 _SC_ATEXIT_MAX 값 확인.
				========================================================================
				long atexit_max;

				atexit_max = sysconf(_SC_ATEXIT_MAX);
				printf("atexit_max=%ld\n", atexit_max);
				========================================================================

	- on_exit()
		> SunOS 4는 atexit()와 동일한 자신만의 함수를 정의.

	- SIGCHLD
		> 프로세스가 종료될 때 커널은 SIGCHLD 시그널을 부모 프로세스로 보낸다.

5. 자식 프로세스 종료 기다리기
	- 좀비 프로세스(자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우)
		> 자식 프로세스가 부모 프로세스보다 먼저 죽으면 커널이 자식 프로세스를 특수한 프로세스 상태로 바꾼다.
		> 좀비가 된 프로세스는 부모 프로세스가 자신의 상태를 조사하도록 기다린다.
		> 부모 프로세스가 종료된 자식 프로세스로부터 정보를 회수한 다음에야 비로소 자식 프로세스를 공식적으로 종료하고 좀비 상태에서 벗어난다.

	- wait()
		========================================================================
		#include <sys/types.h>
		#include <sys/wait.h>

		pid_t wait(int *status);
		========================================================================
		> 성공: 종료된 프로세스의 pid 반환
			$ 자식 프로세스가 종료되지 않은 경우, 종료될 때까지 블록된다(대기 상태).
			$ 종료된 상태라면, 즉시 반환됨.
				* SIGCHLD 시그널 받은 후에 wait() 호출하면 해당 호출은 즉시 반환됨.
		> 실패: -1 반환, errno 설정
		> status가 NULL이 아니면 자식 프로세스에 대한 추가 정보가 포인터에 저장된다.

	- 특정 프로세스 기다리기
		> 프로세스는 대부분 특정 자식 프로세스만 기다린다.
		> 기다리기 원하는 프로세스의 pid를 알고 있다면 waitpid() 시스템 콜을 사용
			========================================================================
			#include <sys/types.h>
			#include <sys/wait.h>

			pid_t waitpid(pid_t pid, int *status, int options);
			========================================================================
			$ pid
				# < -1: 프로세스 gid가 절댓값과 동일한 모든 자식 프로세스를 기다린다.
				# -1: 모든 자식 프로세스를 기다린다. (wait()과 동일한 방식)
				# 0: 호출한 프로세스와 동일한 프로세스 그룹에 속한 모든 자식 프로세스를 기다린다.
				# > 0 : 인자로 받은 pid와 같은 자식 프로세스를 기다린다.
			$ status: wait()의 status와 동일하게 동작
			$ options(OR로 결합)
				# WNOHANG: 이미 종료된 자식 프로세스가 없다면 블록되지 않고 바로 반환.
				# WUNTRACED: status 인자에 WIFSTOPPED 비트가 설정된다. 셸에서 좀 더 일반적인 작업 제어 구현 가능케 한다.
				# WCONTINUED: status 인자에 WIFCONTINUED 비트가 설정된다. WUNTRACED와 마찬가지로 셸을 구현할 때 유용.

			$ 상태가 바뀐 프로세스의 pid를 반환.
			$ WNOHANG이 설정되고 지정한 자식 프로세스의 상태가 아직 바뀌지 않았다면 0을 반환.
			$ 에러 발생: -1, errno

		> wait(&status) == waitpid(-1, &status, 0); // -1: 모든 자식 프로세스 기다, 0: no flags

	- 좀 더 다양한 방법으로 기다리기
		> waitid()
			========================================================================
			#include <sys/wait.h>

			int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
			========================================================================
			$ wait, waitpid와 마찬가지로 자식 프로세스를 기다리고 상태 변화를 얻기 위해 사용.
			$ idtype
				# P_PID: pid가 id와 일치하는 자식 프로세스를 기다린다.
				# P_GID: gid가 id와 일치하는 자식 프로세스를 기다린다.
				# P_ALL: 모든 자식 프로세스를 기다린다.(id 값은 무시됨)
			$ id
				# id_t: 식별 번호를 나타내는 타입





















