[프로세스 관리]
1) 프로그램, 프로세스, 스레드
	- 바이너리
		> 디스크 같은 저장장치에 기록되어 있는 컴파일된, 실행할 수 있는 코드
		> 프로그램, 때로는 애플리케이션
	- 프로세스
		> 실행 중인 프로그램.
		> 메모리에 적재된 바이너리 이미지, 가상화된 메모리의 인스턴스, 열린 파일 같은 커널 리소스, 관련된 사용자 정보와 같은 보안 정보, 하나 이상의 스레드 포함.
			$ 스레드: 프로세스 내 실행 단위(스택, 레지스터, 명령어 포인터 같은 프로세서의 상태 포함)
		> 싱글 스레드 프로세스는 프로세스가 곧 스레드.
			$ 가상화된 메모리 인스턴스 하나와 가상 프로세서 하나가 존재.
		> 멀티 스레드 프로세스
			$ 스레드 여러개 존재
			$ 프로세스와 관련된 가상 메모리는 모든 스레드가 같은 주소 공간을 공유.

2) 프로세스 ID
	- PID(프로세스 ID)
		> 유일한 식별자(모든 프로세스는 pid로 구분)
		> 유일한 값 보장
		> 동작 중인 다른 프로세스가 없을 때 커널이 실행하는 idle 프로세스는 pid가 0
		> 부팅 후 커널이 실행하는 최초 프로세스인 init 프로세스의 pid는 1

		> 사용자가 어떤 프로세스를 실행하라고 명시적으로 요청하지 않으면 커널은 독자적으로 적절한 init 프로세스 확인
			<순서 - 가장 먼저 찾은 프로세스를 init 프로세스로 실행>
			1. /sbin/init: 가장 먼저 찾는 init 프로세스
			2. /etc/init: 두 번째로 찾는 init 프로세스
			3. /bin/init: 우선 탐색에 실패했을 때 찾는 init 프로세스
			4. /bin/sh: 커널이 앞의 순서대로 init 프로세스를 찾는 데 실패한 뒤에 실행하는 본셸의 위치
				* 본셸(bourne shell.bsh)

			* 실행 실패 시: '커널 패닉'을 일으키며 시스템을 중단
				* 커널 패닉: 윈도우즈의 블루스크린과 동일한 것으로 간주.

	- 프로세스 ID 할당
		> 보통 커널의 최대 pid 값: 32768(2^15) 
			* 32768: 부호형signed 16비트 정수를 사용했던 오래된 유닉스 시스템과의 호환성을 위함
			* 지금은 4194304: (2^22) 커널이 22bit range 허용.(예전엔 16비트)
			> 32비트: 32768, 64비트: 4194304
		> /proc/sys/kerner/pid_max 값을 수정하여 사용 가능.(단 호환성 일부 포기)
		> 앞선 pid 값이 비어 있더라도 재사용되지 않는다.

	- 프로세스 계층
		> 부모 프로세스: 새로운 프로세스를 생성하는(Spawn) 프로세스
		> 자식 프로세스: 새롭게 생성된 프로세스(관계는 프로세스의 부모 프로세스(ppid)를 보면 확인 가능)

		> 모든 프로세스는 사용자와 그룹이 소유한다(단순한 정수 값).
			$ 소유: 리소스에 대한 접근 권한 제어하기 위함
			$ 모든 자식은 부모 프로세스의 사용자와 그룹 권한을 상속받는다.

		> 모든 프로세스는 다른 프로세스와의 관계를 표현하고 있는 프로세스 그룹의 일부
			$ 자식 프로세스는 보통 부모 프로세스의 프로세스 그룹에 속하게 된다.

	- pid_t
		> 프로그램에서 pid는 pid_t 자료형으로 표현 (<sys/types.h> 헤더 파일에 정의됨)

	- 프로세스 ID와 부모 프로세스 ID 얻기
		> getpid() 시스템 콜: 호출한 프로세스의 pid를 반환
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getpid(void);
			========================================================================

		> getppid() 시스템 콜: 호출한 프로세스의 부모 프로세스의 pid를 호출
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getppid(void);
			========================================================================

		* 두 시스템 콜은 에러를 반환하지 않는다.

3) 새로운 프로세스 실행하기
	- 실행(exec): 프로그램 바이너리를 메모리에 적재하고 프로세스의 주소 공간에 있는 이전 내용을 대체한 다음, 새로운 프로그램의 실행을 시작
	- 포크(fork): 부모 프로세스를 거의 그대로 복제하여 새로운 프로세스를 생성, 대게 새로운 프로세스는 즉시 새 프로그램을 실행.

	- 새로운 프로그램 실행
		1. 새로운 프로세스를 포크(fork)
		2. 생성된 프로세스에 새로운 바이너리를 적재하여 실행하는 과정 필요.

	- exec 함수들
		> execl() 시스템 콜
			========================================================================
			#include <unistd.h>

			int execl(const char *path, const char *arg, ...);
			========================================================================
			$ 현재 프로세스를 path가 가리키는 프로그램으로 대체
			$ ...는 가변 인자로, 반드시 NULL로 끝나야 함.

			(예제)
			========================================================================
			int ret;
			ret = execl("/bin/vi", "vi", NULL);
			if(ret==-1)
				perror("execl");
			========================================================================
			$ path인 "/bin/vi"의 마지막 요소, vi를 첫 번째 인자로 두어, 프로세스의 fork()/exec 과정에서 argv[0]을 검사하여 바이너리 이미지의 이름 검색

			(예제)
			========================================================================
			int ret;
			ret = execl("/bin/vi", "vi", "/home/kidd/hooks.txt", NULL);
			if(ret == -1)
				perror("execl");
			========================================================================
			$ vi 편집기를 사용해서 hooks.txt 파일을 편집.

		> 일반적으로 execl()은 반환값이 없다.
			$ 성공
				# 새로운 프로그램의 시작점으로 건너뛰며 이전에 실행했던 코드는 그 프로세스의 주소 공간에 더 이상 존재하지 않음. 
				# 프로세스의 주소 공간과 프로세스 이미지뿐만 아니라, 다음과 같이 프로세스의 다른 속성들도 변경
					@ 대기 중인 시그널 사라짐
					@ 프로세스가 받은 시그널은 디폴트 방식으로 처리됨
					@ 메모리 락이 해제됨
					@ 스레드의 속성 대부분이 기본값으로 돌아감
					@ 프로세스의 통계 대부분이 재설정됨
					@ 메모리에 맵핑된 파일을 포함하여 그 프로세스의 메모리 주소 공간과 관련된 모든 내용이 사라짐
					@ C 라이브러리의 기능 atexit() 내용처럼 사용자 영역에만 존재하는 모든 내용이 사라짐

				* 하지만, pid, ppid, 우선순위, 소유자와 그룹처럼 변경되지 않는 속성도 존재.
				
		> 에러: -1, errno 설정

		* exec 호출 과정에서 열린 파일은 그대로 상속된다.
			$ 새롭게 실행되는 프로그램이 fd 값을 알고 있으면 원래 프로세스에서 열었던 모든 파일에 접근이 가능
				--> exec 호출 전 파일을 모두 close() 해라
				--> fcntl()을 통해서 커널이 이 과정을 자동적으로 수행하도록 지시 가능.

		> 다른 exec 함수들
			$ execlp
				========================================================================
				#include <unistd.h>

				int execlp(const char *file, const char *arg, ...);
				========================================================================
				# execl + p
				# p는 file 인자 값을 사용자의 실행 경로 환경 변수에서 찾게 됨

			$ execle
				========================================================================
				#include <unistd.h>

				int execle(const char *path, const char *arg, ..., char * const envp[]);
				========================================================================
				# execl + e
				# 새롭게 생성될 프로세스를 위한 새로운 환경을 제공

			(예제)
			========================================================================
			int ret;
			ret = execvp("vi", "vi", "/home/kidd/hooks.txt", NULL);
			if(ret == -1)
				perror("execl");
			========================================================================	
			$ 사용자의 실행 경로에서 vi 실행 프로그램을 찾는다.

			(execlp()와 execvp() 함수의 보안 위험)
			* 실행 파일의 사용자나 그룹으로 실행되는 프로세스인 SGID와 SUID 프로그램은 절대로 직접 셸을 실행하거나 셸을 실행하는 작업을 해서는 안된다.
				--> 그 작업을 실행하는 사용자가 환경 변수를 변경하여 셸의 동작을 조작할 수 있는 보안상의 문제 발생.
				--> 가로채기(Path Injection): execlp()가 원하는 바이너리를 실행하도록 PATH 변수를 변경하여 해당 바이너리의 SGID 혹은 SUID 권한으로 프로그램을 실행
				# SGID: Set Group ID
				# SUID: Set User ID

			$ execv
				========================================================================
				const char *args[] = {"vi", "/home/kidd/hooks.txt", NULL};
				int ret;

				ret = execv("/bin/vi", args);
				if(ret==-1)
					perror("execv");
				========================================================================
				$ 위는 인자를 args 배열로 받으며 기본 인자로 받는 함수와 동작은 동일.
				$ 배열을 사용: 필요한 인자를 실행 시간(RunTime)에 동적으로 결정할 수 있다는 장점.

			$ execve
				========================================================================
				#include <unistd.h>

				int execve(const char *filename, char *const argv[], char *const envp[]);
				========================================================================
				# 시스템 콜로 존재하는 함수(나머지는 wrapper 함수)
				# 사용자 함수와 동일.
				* 가변 인자를 쓰는 시스템 콜은 구현하기 어렵고 실행 경로라는 개념은 사용자 공간에서만 존재

	- fork() 시스템 콜
		> 현재 실행 중인 프로세스와 동일한 프로세스 새롭게 실행 가능.
			========================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t fork(void);
			========================================================================
			$ 호출 성공: fork()를 실행한 프로세스와 거의 모든 내용이 동일한 새로운 프로세스를 생성.
				# 두 프로세스는 계속 실행 상태, fork()로 새롭게 생성된 프로세스는 아무 일도 없었던 것처럼 계속 실행.
				# 부모(원래 프로세스) <--> 자식(새롭게 생성된 프로세스)
				# 부모: 반환값 자식 프로세스의 pid
				# 자식: 반환값 0

				# 필수 항목
					* 자식 프로세스의 pid는 부모 프로세스와 다른 값으로 할당
					* 자식 프로세스의 ppid는 부모 프로세스의 pid
					* 자식 프로세스에서 리소스 통계는 0으로 초기화
					* 처리되지 않은 시그널은 모두 사라지고 자식 프로레스로 상속되지 않음
					* 부모의 파일 락은 자식으로 상속되지 않음.

			$ 호출 실패: -1 반환, errno 설정(자식 프로세스 생서되지 않음)

			(예제)
			========================================================================
			pid_t pid;

			pid = fork();
			if(pid>0)
				printf("I am the parent of pid=%d\n", pid);
			else if(!pid)
				printf("I am the child!\n");
			else if(pid == -1)
				perror("fork");
			========================================================================

		> 흔한 사례는 새로운 프로세스를 생성하고 그 후에 새 프로세스에 새로운 바이너리 이미지를 올리는 것.
		> fork() + exec
			$ 어떤 프로세스에서 새로운 프로세스를 생성하고 자식 프로세스에서 새로운 바이너리 이미지를 실행

			(예제)
			========================================================================
			pid_t pid;
			pid = fork();
			if(pid == -1)
				perror("fork");

			/* 자식 프로세스 */
			if(!pid){
				const char *args[] = {"windlass", NULL};
				int ret;

				ret = execv("/bin/windlass", args);
				if(ret == -1){
					perror("execv");
					exit(EXIT_FAILURE);
				}
			}
			========================================================================
			$ 새로운 프로세스를 생성하고 /bin/windlass 바이너리를 실행.

		> copy-on-write
			$ fork() 호출 시
				1. 커널은 모든 내부 데이터 구조의 복사본을 생성
				2. 프로세스의 페이지 테이블 항목을 복제
				3. 페이지 단위로 부모 프로세스의 주소 공간의 복사본을 자식 프로레스의 새로운 주소 공간으로 복사

			$ 리눅스, 최신 유닉스에서는...
				# 부모 프로세스 주소 공간을 모두 복사하는 게 아닌 페이지에 대한 copy-on-write 수행.

			$ 복사에 의한 부하를 완화하기 위한 일종의 지연 최적화(lazy optimization) 기법
			$ 쓰기 작업을 할 경우에만 복사가 일어나기 때문에 copy-on-write
				# 단순히 리소스에 대한 포인터만 넘겨 받음
				# 변경 시도시, 해당 리소스는 복사되고 그 복사본을 변경 요청한 츠게 전달.
				# 다른 곳에서는 여전히 변경되지 않은 원본을 공유.
				# 변경 요청한 측에서는 복사본에 대해서 변경 수행 가능.

				(장점)
				1. 리소스의 복사본에 대한 변경이 필요 없을 때는 복사가 발생하지 않음.
				2. 필요한 시점까지 비용이 높은 연산을 미루는 일반적인 지연 알고리즘의 장점 취함.

			$ 페이지 기반으로 구현된다.
				# 부모와 자식 프로세스는 원본 페이지를 공유하고 있으며 공유하고 있는 페이지 역시 다른 부모나 자식 프로세스와 함께 공유하고 있다.

	- vfork()
		$ copy-on-write 도입 전 fork() 직후 exec가 이어지면 쓸모없는 주소 공간을 복사한다는 점을 해결하기 위해 개발

		========================================================================
		#include <sys/types.h>
		#include <unistd.h>

		pid_t vfork(void);
		========================================================================
		$ 자식 프로세스가 종료되든가 새로운 바이너리 이미지를 실행할 때까지 부모 프로세스를 잠시 멈춰두어 프로세스 주소 공간과 페이지 테이블 복사를 회피.

		$ 하는 일: 커널 내부 자료 구조를 복사 --> 자식 프로세스는 주소 공간 내의 어떤 메모리도 변경하면 안된다.

		* copy-on-write의 등장으로 vfork()는 장점이 없어짐.

4) 프로세스 종료하기
	- 종료 함수
		========================================================================
		#include <stdlib.h>

		void exit(int status);
		========================================================================
		$ 반환값이나 에러를 확인할 방법이 없음.

		$ EXIT_SUCCESS, EXIT_FAILURE
			========================================================================
			exit(EXIT_SUCCESS);
			========================================================================
			# 성공: 0
			# 실패: 1이나 -1처럼 0이 아닌 값

		$ 프로세스 종료 순서
			1. atexit()나 on_exit()에 등록된 함수가 있다면 등록 순서의 역순으로 호출.
			2. 열려 있는 모든 포준 입출력 스트림의 버퍼를 비운다.
			3. tmpfile() 함수를 통해 생성한 임시 파일 삭제.
			* 이 과정은 프로세스가 사용자 영역에서 해야 하는 모든 작업을 종료.
			* 그리고 exit()는 _exit() 시스템 콜을 실행해서 프로세스 종료의 나머지 단계를 커널이 처리하게 한다.
				========================================================================
				#include <unistd.h>

				void _exit(int status);
				========================================================================
				# 프로세스가 종료되면 커널은 해당 프로세스가 생성한 더 사용되지 않는 모든 리소스를 정리
					(할당된 메모리, 열린 파일, 시스템 V 세마포어)
					--> 이 모든 작업이 끝나면, 커널은 프로세스를 종료하고 자식 프로세스가 종료 됨을 부모에게 알려준다.

				* 앱에서 _exit()를 직접 호출하는 경우는 거의 없음.
				* 직접 사용할 경우, 앱은 표준 출력 스트림을 지우는 등의 사후 처리를 직접 해야함.
				(단, vfork() 사용시 _exit()를 exit() 대신에 사용해야 함)

	- 프로세스를 종료하는 다른 방법들
		> exit() 사용
		> main() 함수에서 반환값을 지정하여 명시적으로 종료 상태 반환
		> 프로세스를 종료시키는 시그널인 SIGTERM과 SIGKILL을 보내서 프로세스 종료
		
		(예외적 방법)
		> 커널은 잘못된 연산을 수행한다든가,
		> 세그멘테이션 폴트를 일으키거나,
		> 메모리를 고갈시키거나,
		> 허용된 것보다 더 많은 리소스를 소모할 경우
		--> 프로세스를 강제로 죽이기도 한다.

	- atexit()
		> 프로세스가 종료될 때 실행할 함수를 등록하기 위한 용도로 사용된다.
		========================================================================
		#include <stdlib.h>

		int atexit(void (*function)(void));
		========================================================================
		> 성공: 0
		> 에러: -1
		> exit() 혹은 main() 함수에서 return문에 도달해서 프로세스가 정상적으로 종료될 때 호출할 함수를 등록.
		* 시그널에 의해 프로세스가 종료되면 등록된 함수는 호출되지 않음.
		* 등록할 함수는 다음과 같은 아무런 인자도 없고 값도 반환하지 않는 함수여야 한다.
			========================================================================
			void my_function(void); // 반환값 void, 인자 void
			========================================================================

		> 등록된 함수는 등록된 순서의 역순으로 호출됨(스택에 저장되며 LIFO로 실행됨)
		> ATEXIT_MAX 만큼의 함수를 등록할 수 있도록 정하고 있으며 값은 32 이상.
			$ 정확한 값: sysconf() 함수에서 _SC_ATEXIT_MAX 값 확인.
				========================================================================
				long atexit_max;

				atexit_max = sysconf(_SC_ATEXIT_MAX);
				printf("atexit_max=%ld\n", atexit_max);
				========================================================================

	- on_exit()
		> SunOS 4는 atexit()와 동일한 자신만의 함수를 정의.

	- SIGCHLD
		> 프로세스가 종료될 때 커널은 SIGCHLD 시그널을 부모 프로세스로 보낸다.

5. 자식 프로세스 종료 기다리기
	- 좀비 프로세스(자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우)
		> 자식 프로세스가 부모 프로세스보다 먼저 죽으면 커널이 자식 프로세스를 특수한 프로세스 상태로 바꾼다.
		> 좀비가 된 프로세스는 부모 프로세스가 자신의 상태를 조사하도록 기다린다.
		> 부모 프로세스가 종료된 자식 프로세스로부터 정보를 회수한 다음에야 비로소 자식 프로세스를 공식적으로 종료하고 좀비 상태에서 벗어난다.

	- wait()
		========================================================================
		#include <sys/types.h>
		#include <sys/wait.h>

		pid_t wait(int *status);
		========================================================================
		> 성공: 종료된 프로세스의 pid 반환
			$ 자식 프로세스가 종료되지 않은 경우, 종료될 때까지 블록된다(대기 상태).
			$ 종료된 상태라면, 즉시 반환됨.
				* SIGCHLD 시그널 받은 후에 wait() 호출하면 해당 호출은 즉시 반환됨.
		> 실패: -1 반환, errno 설정
		> status가 NULL이 아니면 자식 프로세스에 대한 추가 정보가 포인터에 저장된다.

	- 특정 프로세스 기다리기
		> 프로세스는 대부분 특정 자식 프로세스만 기다린다.
		> 기다리기 원하는 프로세스의 pid를 알고 있다면 waitpid() 시스템 콜을 사용
			========================================================================
			#include <sys/types.h>
			#include <sys/wait.h>

			pid_t waitpid(pid_t pid, int *status, int options);
			========================================================================
			$ pid
				# < -1: 프로세스 gid가 절댓값과 동일한 모든 자식 프로세스를 기다린다.
				# -1: 모든 자식 프로세스를 기다린다. (wait()과 동일한 방식)
				# 0: 호출한 프로세스와 동일한 프로세스 그룹에 속한 모든 자식 프로세스를 기다린다.
				# > 0 : 인자로 받은 pid와 같은 자식 프로세스를 기다린다.
			$ status: wait()의 status와 동일하게 동작
			$ options(OR로 결합)
				# WNOHANG: 이미 종료된 자식 프로세스가 없다면 블록되지 않고 바로 반환.
				# WUNTRACED: status 인자에 WIFSTOPPED 비트가 설정된다. 셸에서 좀 더 일반적인 작업 제어 구현 가능케 한다.
				# WCONTINUED: status 인자에 WIFCONTINUED 비트가 설정된다. WUNTRACED와 마찬가지로 셸을 구현할 때 유용.

			$ 상태가 바뀐 프로세스의 pid를 반환.
			$ WNOHANG이 설정되고 지정한 자식 프로세스의 상태가 아직 바뀌지 않았다면 0을 반환.
			$ 에러 발생: -1, errno

		> wait(&status) == waitpid(-1, &status, 0); // -1: 모든 자식 프로세스 기다, 0: no flags

	- 좀 더 다양한 방법으로 기다리기
		> waitid()
			========================================================================
			#include <sys/wait.h>

			int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
			========================================================================
			$ wait, waitpid와 마찬가지로 자식 프로세스를 기다리고 상태 변화를 얻기 위해 사용.
			$ idtype
				# P_PID: pid가 id와 일치하는 자식 프로세스를 기다린다.
				# P_GID: gid가 id와 일치하는 자식 프로세스를 기다린다.
				# P_ALL: 모든 자식 프로세스를 기다린다.(id 값은 무시됨)
			$ id
				# id_t: 식별 번호를 나타내는 타입
			$ options
				# WEXITED: id와 idtype으로 지정된 자식 프로세스가 정상 종료되기를 기다린다.
				# WSTOPEED: 시그널을 받고 실행을 멈춘 자식 프로세스를 기다린다.
				# WCONTINUED: 시그널을 받고 실행을 다시 실행되는 자식 프로세스를 기다린다.
				# WNOHANG: 이미 종료된 자식 프로세스가 없다면 블록되지 않고 바로 반환된다.
				# WNOWAIT: 좀비 상태에 있는 프로세스를 제거하지 않으며 나중에 다시 이 프로세스를 기다릴 수 있다.
			$ infop
				# si_pid: 자식 프로세스의 pid
				# si_uid: 자식 프로세스의 uid
				# si_code
					@ CLD_EXITED: 자식 프로세스 종료
					@ CLD_KILLED: 시그널에 의해 종료
					@ CLD_STOPEED: 시그널에 의해 멈춤
					@ CLD_CONTINUED: 시그널을 받아서 실행 재개되는 경우
				# si_signo: SIGCHLD를 설정
				# si_status: si_code가 CLD_EXITED라면 자식 프로세스의 종료 코드가 저장됨, 그렇지 않으면 자식 프로세스의 상태 변화를 초래한 시그널 번호가 저장됨.

			$ 성공: 0 반환
			$ 에러: -1, errno 설정
				# ECHLD: id와 idtype으로 지정한 프로세스가 존재하지 않음.
				# EINTR: WNOHANG 옵션을 지정하지 ㅇ낳았고, 시그널에 의해 실행이 중단된 경우
				# EINVAL: options 인자가 유효하지 않거나 id와 idtype 인자의 조합이 유효하지 않음.

			* wait, waitpid와는 달리 siginfo_t 구조체에서 유용한 정보 얻을 수 있음.

	- BSD 방식으로 기다리기: wait3()과 wait4()
		$ BSD는 자식 프로세스의 상태 변화를 기다리기 위한 두가지 독자적인 함수를 제공.

	- 새로운 프로세스를 띄운 다음에 기다리기
		========================================================================
		#define _XOPEN_SOURCE /* WEXITSTATUS 등을 사용할 경우 */
		#include <stdlib.h>

		int system(const char *command);
		========================================================================
		$ 프로세스가 자식 프로세스를 생성한 다음 바로 종료를 기다리는 경우 사용
		$ 동기식 프로세스 생성이 시스템 외부로 셸 띄우기라고 불림.
		$ 간단한 유틸리티나 셸 스크립트를 실행할 목적으로 사용, 종종 실행 결과의 반환값을 얻기 위한 명시적 목적으로 사용
		
		$ 성공: 명령의 상태를 반환
		$ 실행한 명령의 종료 코드: WEXITSTATUS로 얻음.
		$ 에러: -1 반환

		* system()을 반복문 안에서 호출한다면 프로그램이 자식 프로세스의 종료 상태를 적절하게 검사할 수 있도록 해야 한다.

		* 보안 위험성
			@ 공격자가 환경 변수(대부분 path)를 조작하여 권한을 획득할 수 있음. (execlp, execvp와 같은 동일한 보안 이슈에 시달림)
			@ SGID, SUID 프로그램은 셸을 사용하지 않는 fork()와 execl()을 통해 수동으로 실행해야 한다.

	- 좀비 프로세스
		$ 부모 프로세스에서 wait() 시스템 콜을 호출하지 않은 프로세스(적은 리소스를 차지하지만, 시스템 리소스를 계속 소비)

		(만약 부모 프로세스가 자식 프로세스보다 먼저 죽으면?)
			-> 리눅스 커널은 그 프로세스의 자식 프로세스를 모두 뒤져서 모두 init 프로세스(pid가 1인 프로세스)의 자식으로 입양
			-> 부모가 없는 프로세스가 생기지 않도록 보장

6. 사용자와 그룹
	- 프로세스에 연관된 사용자 ID
		1) 실제 사용자 ID
			# 해당 프로세스를 최초 실행한 사용자의 uid
			# 프로그램을 실제로 실행하는 사용자에게 속한 유효 사용자 ID
		2) 유효 사용자 ID
			# 해당 프로세스가 현재 영향을 미치고 있는 사용자 ID
		3) 저장된 사용자 ID
			# 해당 프로세스의 최초 유효 사용자 ID
			# exec 과정에서 suid 바이너리로 변경되기 전까지 유효한 사용자 ID
		4) 파일시스템 사용자 ID

		* 유효한 사용자 ID
			# 가장 중요한 값
			# 프로세스의 자격을 확인하는 과정에서 점검하는 사용자 ID
			# 실제 사용자 ID와 저장된 사용자 ID는 대리인처럼 동작

	- 실제, 저장된 사용자, 그룹 ID 변경하기
		========================================================================
		#include <sys/types.h>
		#include <unistd.h>

		int setuid(uid_t uid); // 사용자 ID
		int setgid(gid_t gid); // 그룹 ID
		========================================================================
		$ setuid
			# 현재 프로세스의 유효 사용자 ID를 설정.
			# 프로세스의 현재 유효 사용자 ID가 0(root)이면 실제 사용자와 저장된 사용자 ID 역시 설정됨.
			# root 사용자는 uid로 어떤 값이든 사용 가능.
			# 성공: 0 반환
			# 에러: -1 반환, errno 설정.
				@ EAGAIN: uid가 실제 사용자 ID와 다름, 실제 사용자 ID를 uid 값으로 설정하는 작업이 RLIM_NPROC(사용자가 소유할 수 있는 최대 프로세스 개수)를 초과.
				@ EPERM: 사용자가 root가 아니며 uid 값이 유효 사용자 ID도 저장된 사용자 ID도 아님.

	- 유효 사용자 ID나 유효 그룹 ID 변경하기
		========================================================================
		#include <sys/types.h>
		#include <unistd.h>

		int seteuid(uid_t uid); // 유효 사용자 ID
		int setegid(gid_t gid); // 유효 그룹 ID
		========================================================================
		$ seteuid
			# 유효 사용자 ID를 euid로 설정.
			# root: euid를 어떤 값이든 사용 가능
			# 비root: 실제 사용자 ID, 저장된 사용자 ID만 사용 가능.
			# 성공: 0
			# 에러: -1, errno 설정
				@ EPERM: 현재 프로세스가 root 소유가 아님, euid가 실제 사용자 ID도 저장된 사용자 ID도 아님.

	- 바람직한 사용자 / 그룹 ID 조작법.
		$ 비root 프로세스
			# seteuid()를 사용해서 유효 사용자 ID를 바꿔야 한다.

		$ root 프로세스
			# setuid()를 사용해서 세가지 사용자 ID를 모두 바꿈. (유효 사용자 ID만 임시로 바꾸려고 하면 seteuid()를 사용)

	- 사용자 ID와 그룹 ID 얻어오기
		========================================================================
		#include <sys/types.h>
		#include <unistd.h>

		uid_t getuid(void);
		gid_t getgid(void);

		uid_t geteuid(void); 
		gid_t getegid(void); 
		========================================================================
		$ 호출은 실패하지 않으며, 각각 유효 사용자 ID, 유효 그룹 ID를 반환한다.

7. 세션과 프로세스 그룹
	- 프로세스 그룹: 하나 이상의 프로세스를 모아놓은 집합
		$ 속성
			# 그룹 내 모든 프로세스에게 시그널 보내기
			# 하나의 시그널로 같은 프로세스 그룹에 속한 모든 프로세스 종료, 멈추거나 다시 실행 가능
		$ 그룹은 pgid(프로세스 그룹 ID)로 구분
		$ 각 그룹은 그룹 리더 존재(그룹 ID는 리더의 pid와 동일)
		$ 그룹 리더가 종료되어도 그룹은 남아있음.

	- 세션: 대부분 셸과 관련을 맺음.
		$ 제어 터미널을 둘러싼 로그인을 통합하는 기능 제공.
		$ 모든 세션은 하나 이상의 프로세스 그룹, 프로세스 그룹은 하나 이상의 프로세스를 포함.
		$ 세션에 속한 프로세스 그룹
			# 하나의 Foreground 프로세스 그룹(사용자에게 직접 연결되어 있고 터미널 제어가 가능한 프로세스 그룹 중 하나)
			# 0개 이상의 Background 프로세스 그룹

			* 사용자가 터미널 종료 시
				-> Foreground 프로세스 그룹 내 모든 프로세스에 SIGQUIT 시그널 전달
			* 터미널에서 네트워크 단절 포착 시
				-> Foreground 프로세스 그룹 내 모든 프로세스에 SIGHUP 시그널 전달
			* 사용자가 터미널에서 Ctrl+c 같은 취소 명령 입력 시
				-> Foreground 프로세스 그룹 내 모든 프로세스에 SIGINT 시그널 전달
		(예) ===========================================================================
			 사용자가 시스템에 로그인, 로그인 셸인 bash의 pid가 1700인 경우
				-> bash 인스턴스는 gid가 1700인 새로운 프로세스 그룹의 유일한 멤버이자 리더가 된다.

		(예) =================================================================
			$ cat ship-inventory.txt | grep booty | sort
				--> 세개의 프로세스를 가지는 하나의 프로세스 그룹을 생성(한 번에 세 프로세스 모두에 시그널을 보낼 수 있다는 뜻)
				--> 명령어 뒤에 &를 붙이지 않았으므로 포어그라운드에서 동작.

	- 세션 시스템 콜
		$ 시스템 로그인 시점에 셸은 새로운 세션을 생성.
			======================================================================
			#include <unistd.h>

			pid_t setsid(void);
			======================================================================
			# 프로세스가 프로세스 그룹의 리더가 아니라고 가정하고 새로운 세션을 생성.
			# 호출한 프로세스는 새롭게 만들어진 세션의 유일한 멤버이자 리더가 되며 제어 tty(teletypewriter)를 가지지 않음.
			# 세션 내 새로운 프로세스 그룹을 만들어 호출한 프로세스를 그 프로세스 그룹의 유엘한 멤버이자 리더로 등록.
			# 만들어진 새로운 세션과 프로세스 그룹의 ID는 호출한 프로세스의 pid가 된다.

			* setsid()는 새로운 세션 내부에 새로운 프로세스 그룹을 생성, 호출한 프로세스를 그 세션과 프로세스 그룹 모두의 리더로 등록.
			* 기존 세션에 속하고 싶지 않거나 제어 터미널을 원치 않는 데몬, 사용자가 로그인할 때마다 새로운 세션을 생성해야 하는 셸에서 유용.

			# 성공: 새롭게 생성한 세션의 ID 반환.
			# 실패: -1, errno 설정(EPERM: 프로세스가 현재 프로세스 그룹의 리더임을 알려줌)

			* 어떤 프로세스가 프로세스 그룹 리더가 되지 않게 하는 방법
				1) 프로세스를 포크
				2) 부모 프로세스 종료
				3) 자식 프로세스에서 setsid() 호출.

			======================================================================
			#define _XOPEN_SOURCE 500
			#include <unistd.h>

			pid_t getsid(pid_t pid);
			======================================================================
			# pid가 가리키는 프로세스 세션 ID 반환.
			# pid 값이 0 이면, 호출한 프로세스의 세션 ID를 반환.
			# 실패하면 -1 반환, errno: ESRCH(pid가 유효한 프로세스가 아님)

			* 주로 진단 목적으로 사용됨.

	- 프로세스 그룹 시스템 콜
		$ setpgid(): pid 인자로 지정한 프로세스의 프로세스 그룹 ID를 pgid로 설정.
			======================================================================
			#define _XOPEN_SOURCE 500
			#include <unistd.h>

			int setpgid(pid_t pid, pid_t pgid);
			======================================================================	
			# pid가 0인 경우 현재 프로세스의 프로세스 그룹 ID를 변경하며 pgid 인자가 0인 경우 pid 인자로 지정한 프로세스의 ID를 프로세스 그룹 ID로 설정.
			# 성공: 0 반환
			(성공 여부)
				@ pid로 지정한 프로세스가 해당 시스템 콜을 호출하는 프로세스이거나 호출하는 프로세스의 자식 프로세스, 아직 exec 호출을 하지 않았고 부모 프로세스와 동일한 세션에 속해 있어야 함
				@ pid로 지정한 프로세스가 세션의 리더가 아님
				@ pgid가 이미 있으며 호출하는 프로세스와 동일한 세션에 속해 있어야 함
				@ pgid 값이 양수.
			# 에러: -1 반환, errno 설정.

		$ getpgid(): 세션과 마찬가지로 프로세스의 프로세스 그룹 ID를 얻는 것(유용하지는 않음)
			======================================================================
			#define _XOPEN_SOURCE 500
			#include <unistd.h>

			pid_t getpgid(pid_t pid);
			======================================================================	
			# pid로 지정한 프로세스의 프로세스 그룹 ID를 반환.
			# pid 인자가 0: 현재 프로세스의 프로세스 그룹 ID 반환.
			# 에러: -1, errno 설정(ESRCH: 유효한 프로세스 ID가 아님)
			# 주로 진단 목적으로 사용됨.

	- 사용되지 않는 프로세스 그룹 관련 함수들

9. 데몬(DAEMON)
	- 백그라운드에서 수행되며 제어 터미널이 없는 프로세스
	- 부팅 시에 시작되며 root 혹은 다른 툭수한 사용자 계정 권한으로 실행되어 시스템 수준의 작업을 처리
	- 사용자가 포어그라운드에서 처리하기를 꺼리는 작업을 수행

	(요구사항)
	1) init 프로세스의 자식 프로세스여야 함
	2) 터미널과 연결되어 있으면 안된다.

	(데몬이 되는 과정)
	1) fork() 호출(새로운 프로세스 생성)
	2) 부모 프로세스에서 exit을 호출해서 부모 프로세스 종료 -> 프로세스 그룹의 리더가 되지 않도록 한다.
	3) setsid()를 호출하여 데몬이 새로운 프로세스 그룹과 세션의 리더가 되도록 한다. -> 제어 터미널에 연관되지 않도록 한다.
	4) chdir()를 사용하여 작업 디렉터리를 루트 디렉터리로 변경(임의의 디렉터리가 계속 열린 상태로 방치되어 관리자가 그 디렉터리를 포함하는 파일 시스템을 마운트 해제할 수 없게 되는 상황을 회피하기 위함)
	5) 모든 파일 디스크립터를 닫는다 -> 상속받은 파일 디스크립터를 열린 채로 두기 원하지 않기 때문
	6) 0, 1, 2번 파일 디스크립터(stdin, stdout, error)를 열고 /dev/null로 리다이렉트.

		$ daemon() 함수
			======================================================================
			#include <unistd.h>

			int daemon(int nochdir, int noclose);
			======================================================================	
			# nochdir 인자 0이 아니면 현재 작업 디렉터리를 루트 디렉터리로 변경하지 않음
			# noclose 잊가 0이 아니면 열려있는 모든 파일 디스크립터를 닫지 않음.

			* 일반적으로 인자를 모두 0으로 넘긴다.

			# 성공: 0 반환
			# 실패: -1 반환.


























