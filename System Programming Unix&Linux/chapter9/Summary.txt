IPC(InterProcess Communication)
  - 동일한 시스템 안에서 수행 중인 프로세스끼리 데이터를 주고받는 것.
  - 파이프와 같은 특수 파일을 이용, 메모리 매핑이나 공유 메모리 같은 메모리 영역을 이용하는 방법
  - 메세지 큐, 공유 메모리, 세마포어 등 유닉스 시스템 V에서 제공하는 IPC 방법
  - (넓은 의미) 종료상태(Exit Status)와 시그널 같은 정숫값을 주고받는 것도 포함.
    (예: 자식 프로세스가 종료하면서 부모 프로세스에 종료 상태를 알리는 값을 보내는 것 - 가장 단순한 형태의 프로세스 간 통신)
  - 시그널도 프로레스 사이에서 데이터를 주고받으므로 프로세스 간 통신 방법의 하나로 간주 가능.

네트워크를 이용한 통신
  - 네트워크를 이용한 통신은 TCP/IP 프로토콜을 기본으로 하며, 소켓 라이브러리를 이용.
    (TLI가 있지만 소켓 라이브러리에 밀려 거의 사용하지 않음.)
    Transport Layer Interface

메모리 매핑
  - mmap(): 메모리 매핑
  - munmap(): 메모리 매핑 해제
  - mprotect(): 메모리 보호 모드 변경
  - truncate(), ftruncate(): 파일 크기 조정
  - *mremap(): 메모리 매핑 변경
  - msync(): 매핑된 메모리 동기화.

메모리 매핑 해제
  - 메모리 매핑: 파일을 프로세스의 메모리에 매핑하는 것
    (프로세스에 전달할 데이터를 저장한 파일을 직접 프로세스의 가상 주소 공간으로 매핑)
  - read(), write() 함수를 사용하지 않고도 프로그램 내부에서 정의한 변수를 사용해 파일에서 데이터를 읽거나 쓸 수 있음.

메모리 매핑 함수
  - mmap(): 파일을 프로세스의 가상 메모리에 매핑 가능.

    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

    addr: 매핑할 메모리의 주소
      * 주소를 직접 지정하거나 그렇지 않을 경우 NULL 사용.
      * NULL이 아닌 경우, 커널은 addr에 지정된 값의 근처 메모리 영역을 페이지 단위로 사용.
      * NULL을 지정하면 시스템이 가장 적합한 메모리로 데이터를 매핑.
      * 대부분 0을 넘김.		
    length: 메모리 공간의 크기(매핑할 메모리 공간의 크기 지정)
      * 반드시 0보다 커야 함.
      * 파일 전체를 매핑할 경우 파일 크기를 지정.
    prot: 보호 모드(읽기, 쓰기 등 보호 모드 지정 - OR 연산자 가능)
      * PROT_READ: 매핑된 파일을 읽기만 함.
      * PROT_WRITE: 매핑된 파일에 쓰기를 허용(flags 인자에 MAP_PRIVATE를 지정하거나 파일을 쓰기 가능 상태로 열어야 함)
      * PROT_EXEC: 매핑된 파일을 실행할 수 있음.
      * PROT_NONE: 매핑된 파일에 접근할 수 없다.
    flags: 매핑된 데이터의 처리 방법 지정 상수(읽어온 데이터를 처리하기 위한 정보를 지정 - OR 연산자 가능)
      * MAP_SHARED: 다른 프로세스와 데이터 변경 내용 공유, 쓰기 동작은 매핑된 메모리의 내용을 변경.
      * MAP_SHARED_VALIDATE: MAP_SHARED와 같으나, 전달받은 플래그를 커널이 모두 확인하고 모르는 플래그가 있을 경우 오류로 취급.
      * MAP_PRIVATE: 데이터의 변경 내용을 공유하지 않음. (MAP_SHARED와 MAP_PRIVATE 플래그 중 하나는 반드시 지정해야 함, 둘 다 사용 X)
      * MAP_ANONYMOUS: fd를 무시하고 할당된 메모리 영역을 0으로 초기화. offset은 0이어야 함.
      * MAP_ANON: MAP_ANONYMOUS와 동일한 플래그, 다른 시스템과의 호환성을 위해 제공.
      * MAP_FIXED: 매핑할 주소를 정확히 지정.
      * MAP_NORESERVE: 스왑 영역을 할당하지 않는다.(MAP_PRIVATE를 지정하면 시스템은 매핑에 할당된 메모리 공간만큼 스왑 영역을 할당. 이 스왑 영역은 매핑된 데이터의 사본을 저장하는 데 사용)
    fd: 파일 기술자
    offset: 파일 오프셋

  - 매핑할 메모리의 위치와 크기를 인자로 받음.
  - fd가 가리키는 파일에서 offset으로 지정한 오프셋부터 length 크기만큼 데이터를 읽어 addr이 가리키는 메모리 공간에 매핑.
  - 페이지 단위로 메모리 매핑을 실행.
  - 매핑된 영역의 마지막 페이지에 남는 부분은 0으로 채워짐.
  - 매핑된 메모리 영역 벗어난 공간에 접근 시 SIGBUS, SIGSEGV와 같은 시그널 발생.
  - 수행에 성공하면, 매핑된 메모리의 시작 주소를 리턴.
  - 매핑된 영역의 크기는 (시작주소 + length)
  - 실패하면, MAP_FAILED 리턴.

메모리 매핑 해제 함수
  - mmap() 함수를 사용해 매핑한 메모리 영역을 해제.(해제된 메모리 영역에 다시 접근하려 하면 오류 발생)

    munmap(void *addr, size_t length);

    addr: 매핑된 메모리의 시작 주소
    length: 메모리 영역의 크기

  - 메모리에 매핑된(addr + length) 크기만큼 메모리 영역을 해제
  - munmap 함수로 매핑을 해제한 메모리 영역에 접근하면 SIGSEGV 시그널 발생
  - 성공하면 0, 실패하면 -1 리턴.

메모리 매핑의 보호 모드 변경 함수
  - 메모리로 매핑된 영역의 보호 모드를 변경

    mprotect(void *addr, size_t len, int prot);

    addr: 매핑된 메모리의 시작 주소
    len: 메모리 영역의 크기
    prot: 보호 모드

  - addr로 지정한 주소에 len 크기만큼 매핑된 메모리의 보호 모드를 prot에 지정한 값으로 변경.
  - PROT_READ, PROT_WRITE, PROT_EXEC, PROT_NONE
  - 성공하면 0, 실패하면 -1 리턴.

파일 확장과 메모리 매핑
  - 존재하지 않는 파일, 크기가 0인 파일은 mmap() 함수를 사용해 메모리에 매핑할 수 없다.
  - 빈 파일을 trunacte()이나 ftruncate() 함수를 사용해 파일 크기를 확장하거나 줄인 후 mmap() 함수 호출해야 함.

    [truncate: 경로명을 사용한 파일 크기 확장]
    int truncate(const char *path, off_t length);

    path: 크기를 변경할 파일의 경로
    length: 변경하려는 크기

    * length로 지정한 크기로 파일 크기를 변경 가능
    * 파일의 원래 크기가 length보다 크면 length 길이를 초과하는 부분은 버리고
      length보다 작으면 파일의 크기를 증가시키고 해당 부분을 널 바이트('\0')으로 채움.
    * 함수 사용을 위해서는, 경로로 지정한 파일에 대한 쓰기 권한이 있어야 함.
    * 파일의 오프셋은 변경하지 않지만, 파일의 상태 정보에서 st_ctime과 st_mtime을 수정
    * 성공하면 0, 실패하면 -1 리턴.

    [ftruncate: 파일 기술자를 사용한 파일 크기 확장]
    int ftruncate(int fd, off_t length);

    fd: 크기를 변경할 파일의 파일 기술자
    length: 변경하려는 크기

    * 파일의 경로명 대신 파일 기술자를 받는다.
    * fd에 지정한 파일의 크기를 length로 지정한 크기로 변경.
    * 파일의 원래 크기가 length보다 크면 length 길이를 초과하는 부분은 버리고
      length보다 작으면 파일의 크기를 증가시키고 해당 부분을 널 바이트('\0')으로 채움.
    * 일반 파일(regular file)과 공유 메모리(shared memory)에만 사용 가능.
    * 파일의 오프셋은 변경하지 않지만, 파일의 상태 정보에서 st_ctime과 st_mtime을 수정
    * 쓰기 권한이 없는 파일에 접근하면 오류 발생.
    * 성공하면 0, 실패하면 -1 리턴.

메모리 주소를 다시 매핑하기
  void *mremap(void *old_address, size_t old_size, size_t new_size, int flags);

  old_address: 크기를 변경할 메모리의 주소
    * 현재 매핑된 메모리 주소를 지정
  old_size: 현재 메모리 크기
    * 현재 메모리 크기를 지정
  new_size: 바꾸려는 메모리 크기
    * old_size 보다 크거나 작을 수 있다.
  flags: 0 또는 MREMAP_MAYMOVE
    * MREMAP_MAYMOVE를 지정하면 크기를 변경할 때 매핑의 위치를 이동해도 된다는 뜻.

  - 리눅스에서만 제공하는 함수, 매핑된 메모리의 크기와 위치를 변경할 수 있음.

매핑된 메모리 동기화와 데이터 교환
  - 시스템은 메모리에 매핑된 파일의 내용을 백업 공간에 복사(따라서, 매핑된 메모리의 내용과 백업 내용이 일치하도록 동기화 해야 함.)
  - 매핑한 데이터를 부모 프로세스와 자식 프로세스가 공유할 수 있다.
  - 공유를 사용하면 부모 프로세스와 자식 프로세스가 데이터를 주고받을 수 있다. (IPC 메모리 매핑을 이용할 수 있음)

매핑된 메모리의 동기화 함수
  - mmap() 함수로 메모리에 매핑된 파일의 내용은 백업 공간에 복사된다.
  - MAP_SHARED 모드로 매핑한 메모리 영역의 백업 저장 장치 = 파일
  - MAP_PRIVATE 모드로 매핑한 영역의 백업 저장 장치 = 스왑 공간
  - msync() 함수를 사용 -> 매핑된 메모리 영역과 백업 저장 장치의 내용이 일치하도록 동기화.

매핑된 메모리 동기화 msyc()
  int msync(void *addr, size_t length, int flags);

  addr: 매핑된 메모리의 시작 주소
  length: 메모리 영역의 크기
  flags: 동기화 동작
    * MS_ASYNC, MS_SYNC 중 하나 지정.
      > MS_ASYNC: 비동기 쓰기 작업 수행. msync() 함수는 즉시 리턴, 함수가 리턴한 후 적절한 시점에 쓰기 작업 수행.
      > MS_SYNC: 쓰기 작업을 완료할 때까지 msync() 함수가 리턴하지 않음. 메모리의 크기가 클 경우 시간이 오래 걸릴 수 있음.
    * MS_INVALIDATE는 부가적으로 같이 지정 가능.
      > MS_INVALIDATE: 메모리에 있는 기존 내용을 무효화할 것인지 확인.

  - addr로 시작하는 메모리 영역에서 (addr+length)만큼의 내용을 백업 저장 장치로 기록.
  - 이 함수를 사용하지 않으면 munmap() 함수가 호출되기 전에 변경된 메모리 내용이 저장되는지 보장할 수 없음.
  - 성공 시 0, 실패 시 -1 리턴.
