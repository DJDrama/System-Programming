[프로세스 생성과 실행]
1. 개요
	- 프로세스
		1) 사용자가 명령행에서 직접 프로그램을 실행해 생성하는 경우
		2) 프로그램 안에서 다른 프로그램을 실행해 생성하는 경우(system(), fork(), vfork())
			* 프로그램 실행
				int system(const char *command);
			* 프로세스 생성
				pid_t fork(void);
				pid_t vfork(void);

	- 종료 상태(Exit Status): 프로세스가 어떻게 종료 되었는지를 나타냄.
		$ 0: 정상 종료
		$ 0이 아닌 경우: 오류 발생

		$ 종료할 때 exit(), atexit(), on_exit(), _exit() 함수 사용
			* 프로세스 종료
				void exit(int status);
				void _exit(int status);
			* 종료시 수행할 작업 지정
				int atexit(void (*function)(void));
				int on_exit(void (*function)(int , void *), void *arg);

	- 함수명 'exec'로 시작하는 함수군은 인자로 받은 다른 프로그램을 자신을 호출한 프로세스의 메모리에 덮어씀.
		(수행 중이던 기존 프로그램은 중지되어 없어지고, 새로 덮어쓴 프로그램이 실행된다)
		$ fork() 함수와 연결해 fork() 함수로 생성한 자식 프로세스가 새로운 프로그램을 실행하도록 할 때도 사용.
			* 프로세스 실행
				int execl(const char *pathname, const char *arg, ...);
				int execlp(const char *file, const char *arg, ...);
				int execle(const char *pathname, const char *arg, ..., char *const envp[]);
				int execv(const char *pathname, char *const argv[]);
				int execvp(const char *file, char *const argv[]);
				int execvpe(const char *file, char *const argv[], char *const envp[]);

	- 부모 / 자식 프로세스 동기화
		$ fork() 함수로 자식 프로세스 생성 시, 먼저 실행을 마친 프로세스는 종료된다.
			* 프로세스 동기화
				pid_t wait(int *wstatus);
			* 특정 자식 프로세스와 동기화
				pid_t waitpid(pid_t pid, int *wstatus, int options);
				int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);


2. 프로세스 생성
	- 새로운 프로세스 생성 시: system(), fork(), vfork()

	- system() 함수로 프로그램 실행하기.
		$ 프로그램 안에서 새로운 프로그램을 실행시키는 가장 간단한 방법
			* 명령 실행을 위해 셸까지 동작시키므로 비효율적(남용하는 것은 바람직하지 않음)

			========================================================================
			#include <stdlib.h>

			int system(const char *command);
			========================================================================
			# command: 실행할 명령이나 실행 파일명

			(동작)
			1. 기존 명령이나 실행 파일명을 인자로 받아 셸에 전달
			2. 셸은 내무적으로 새 프로세스 생성
			3. 인자로 받은 명령 실행
			4. 해당 명령 실행 끝날 때까지 기다렸다가 종료 상태 리턴.

	- 프로세스 생성
		$ 프로세스 생성: fork(2)
			================================================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t fork(void); // 성공: 부모 프로세스에는 자식 프로세스의 PID 리턴, 자식 프로세스에는 0 리턴. <-> 실패: -1 리턴.
			================================================================================================
			# 프로세스를 생성해 프로그램을 실행하는 대표적인 방법
			# 부모 프로세스를 거의 그대로 복제해 새로운 프로세스 생성.
			# 함수가 생성한 새로운 프로세스 -> 자식 프로세스

			* 함수 리턴 시: 부모, 자식 프로세스가 동시에 동작. --> 어느 프로세스가 먼저 실행될지 알 수 없다.(시스템 스케줄링에 따라 달라짐)

			(fork() 함수의 특징)
			# (동작)
				1) fork() 함수 호출
				2) 새로운 프로세스(자식) 생성
				3) 자식 프로세스의 메모리 공간은 부모 프로세스의 메모리 공간을 그대로 복사해서 만듦.
				4) 부모 프로세스에는 자식 프로세스의 PID 리턴, 자식 프로세스에는 0 리턴.

			# 자식은 부모 프로세스의 메모리 복사 및 다양한 속성 상속받음.
				@ RUID, EUID, RGID, EGID
					+ RUID: 실제 사용자 ID
					+ EUID: 유효 사용자 ID
					+ RGID: 실제 그룹 ID
					+ EGID: 유효 그룹 ID
				@ 환경 변수
				@ 열린 파일 기술자
				@ 시그널 처리 설정
				@ setuid, setgid 설정
				@ 현재 작업 디렉터리
				@ umask 설정값
				@ 사용 가능한 자원 제한

			# 자식 프로세스 기준 부모 프로세스와 다른 점
				@ 새로 할당된 pid를 갖는다.
				@ 자식은 부모 ppid와 다른 자신만의 ppid를 가짐(자식 프로세스의 ppid = 부모 프로세스)
				@ 자식은 부모 프로세스가 연 파일 기술자에 대한 복사본 소유. 같은 파일의 오프셋을 공유하므로 읽기 / 쓰기 주의.
				@ 부모 프로세스가 설정한 프로세스 잠금, 파일 잠금, 기타 메모리 잠금 등은 상속받지 않음.
				@ 처리되지 않은 시그널은 자식에게 상속되지 않음.
				@ 자식의 tms 구조체 값은 0으로 초기화.(프로세스 실행 시간 측정 기준 값이 새로 설정됨)

		$ 프로세스 생성: vfork(2)
			================================================================================================
			#include <unistd.h>

			pid_t vfork(void);
			================================================================================================
			# 부모 프로세스의 메모리 공간을 모두 복사하지 않음.
			# exec 함수군을 사용해 새로운 작업 수행 시 효율적.
			# 과거의 유물(사용 추천하지 않음)

3. 프로세스 종료
	- 종료 상태(Exit Status)
		$ 0: 정상 종료
		$ 1: 보통 오류 발생

		$ 프로그램 종료: exit(3)
			================================================================================================
			#include <stdlib.h>

			void exit(int status);
			================================================================================================
			# status: 종료 상탯값
			# 프로세스 종료시키고 부모 프로세스에 종료 상탯값을 전달, atexit() 함수로 예약한 함수를 지정된 순서와 역순으로 모두 실행.
			# atexit() 문제 발생 시 exit() 함수의 나머지 과정도 수행되지 않음.
			# 사용 중이던 모든 표준 입출력 스트림에 데이터가 남아 있으면 이를 모두 기록하고 스트림을 모두 닫는다.
			# tmpfile() 함수로 생성한 임시 파일 모두 삭제하고 _exit() 함수 호출한다.
			# _exit(): 시스템 호출, 프로세스가 사용하던 모든 자원을 반납(exit()은 C 표준 함수--> 시스템 독립적 기능만 수행).

		$ 프로그램 종료 시 수행할 작업 예약: atexit(3)
			================================================================================================
			#include <stdlib.h>

			int atexit(void (*function)(void));
			int on_exit(void (*function)(int , void *), void *arg);
			================================================================================================
			# function: 종료 시 수행할 작업을 지정한 함수명.
			# 프로세스가 종료할 때 수행할 기능을 예약.
			# atexit() 함수에 인자로 지정하는 함수는 인자와 리턴값이 없는 함수.
			# on_exit()은 함수에 인자를 지정할 필요가 있을 경우에만 사용
			# 예약할 수 있는 함수의 개수: sysconf() 함수의 _SC_ATEXIT_MAX (2^31-1)

		$ 프로그램 종료: _exit(2)
			================================================================================================
			#include <stdlib.h>		

			void_exit(int status);
			================================================================================================
			# status: 종료 상탯값
			# 일반적으로 _exit() 함수는 프로그램에서 직접 사용하지 않음(exit() 함수 내부에서 호출되므로)
			# _exit() 함수 시스템 호출로 프로세스 종료 시 시스템 자원 정리 과정
				1) 모든 파일 기술자를 닫음
				2) 부모 프로세스에 종료 상태를 알림
				3) 자식 프로세스에 SIGHUP 시그널을 보냄
				4) 부모 프로세스에 SIGCHLD 시그널을 보냄
				5) 프로세스 간 통신에 사용한 자원 반납.

4. exec 함수군 활용
	- 함수명이 exec로 시작하는 함수들
	- 인자로 받은 다른 프로그램을 자신을 호출한 프로세스의 메모리에 덮어쓴다(수행 중이던 기존 프로그램은 중지되고 새로 덮어쓴 프로그램이 실행됨)
	- 호출한 프로세스 자체가 바뀌므로 성공하면 리턴값은 없다.
	- fork() 함수로 생성한 자식 프로세스가 새로운 프로그램을 실행하도록 할 때 유용.

	- exec 함수군의 형태
		$ int execl(const char *pathname, const char *arg, ...);
			# pathname에 지정한 경로명의 파일을 실행(상대 경로, 절대 경로 모두 가능)
			# arg0~argn 인자 전달.
			# arg0: 실행 파일명 지정.
			# arg 마지막 인자는 NULL
		
		$ int execlp(const char *file, const char *arg, ...);
			# file 에 지정한 파일 실행
		
		$ int execle(const char *pathname, const char *arg, ..., char *const envp[]);
			# envp에는 새로운 환경 변수 설정 가능(마지막에는 NULL 문자열)

		$ int execv(const char *pathname, char *const argv[]);
			# argv는 포인터 배열(마지막에는 NULL)

		$ int execvp(const char *file, char *const argv[]);

		$ int execvpe(const char *file, char *const argv[], char *const envp[]);

	- exec 함수군의 활용
	





