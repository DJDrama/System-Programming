[프로세스 정보]
<01> 개요
	- 프로세스: 현재 실행 중인 프로그램
		$ 상태: 실행, 수면, 실행대기
		$ ps, top 명령어: 현재 실행 중인 프로세스 확인
	- PID: 프로세스 ID
	- 프로세스 그룹: 프로세스들이 모여 구성
	- 세션: POSIX 표준에서 제안, 사용자가 로그인해서 작업하는 터미널 단위로 프로세스 그룹을 묶은 것.

<02> 프로세스의 개념
	(2.1) 프로세스의 정의
		- 프로세스: 실행 중인 프로그램 != 프로그램, 프로세서(와 혼동하지 말아라)
			$ 프로세서: 인텔 코어 등과 같은 CPU(Central Processing Unit: 중앙 처리 장치)
			$ 프로그램: 사용자가 컴퓨터에 작업을 시키기 위한 명령어의 집합(C 언어 같은 고급 언어나 셸 스크립트 같은 스크립트 언어로 작성)
				* 고급언어로 작성한 프로그램은 컴파일러를 통해 기계어 프로그램으로 변환(실행 프로그램 or 실행파일)
				* 인터프리터 방식: 스크립트 언어로 작성한 프로그램은 실행 시 코드를 읽고 해석하여 실행한다.
				--> 이들을 실행하면 프로세스가 된다.

			1. 프로그램 소스 파일 작성 후 컴파일해서 실행 파일 생성
			2. 실행 파일을 메모리에 적재해 실행하면 프로세스가 된다.
			3. 프로세스를 처리하는 것이 바로 프로세서이다.

	(2.2) 프로세스의 구조
		(가변 영역)
			[스택]
			[빈 공간]
			[힙]
		(고정 영역)
			[데이터]
			[텍스트]

		- 스택 영역: 정의한 지역 변수를 저장하는 메모리 영역, 지역 변수를 정의한 부분에서 할당해 사용.
		- 빈 공간: 스택이나 힙과 같이 가변적인 메모리 할당을 위해 유지하고 있는 메모리 영역. 모두 소진 시 메모리 부족으로 프로그램 실행 중단.
		- 힙 영역: 실행 중에 동적으로 메모리를 요청하는 경우에 할당되는 영역(빈 영역->할당->할당 해제: 상태가 변하는 가변 영역)
		- 데이터 영역: 프로그램에서 정의한 전역 변수를 저장. 전역 변수는 프로그램 작성 시 크기가 고정되므로 고정 영역에 할당된다.
		- 텍스트 영역: 실행 코드 저장. 프로세스 실행 중에 크기가 변하지 않는 고정 영역에 속한다.

	(2.3) 프로세스 상태 변화
		1. 프로세스는 사용자 모드에서 먼저 실행된다.
		2. 사용자 모드에서 시스템 호출을 하면 커널 모드로 전환되어 실행된다.
		3. 수면 중이던 프로세스가 깨어나 실행 대기 상태가 되면 바로 실행할 수 있도록 준비한다.
		4. 커널 모드에서 실행 중인 입출력 완료를 기다릴 때와 같이 더 이상 실행을 계속할 수 없을 때 수면 상태로 전환된다.
			* CPU는 한 번에 프로세스 하나만 실행할 수 있다. (실행 중인 많은 프로세스 중 하나만 1, 2 상태이고, 나머지는 3, 4의 상태이다)
			* 실행 대기 상태: CPU를 사용할 수 있을 때까지 기다리는 상태로, 스케줄링에 따라 실행된다.
			* 프로세스의 상태를 적절히 전환하는 일은 커널의 프로세스 관리 기능에 해당한다.

	(2.4) 프로세스 목록 보기
		- ps 명령어 사용
			* 아무 옵션 없이 사용하면 현재 터미널에서 실행한 프로세스만 출력.
		- ps -ef : 시스템에서 동작하고 있는 전체 프로세스 보기.

	(2.5) 시스템 메모리 정보 보기
		- top 명령어: 실행 중인 프로세스를 주기적으로 확인해 출력.
		- 메모리와 스왑 상태 검색: sysinfo(2)
			================================================================================
			#include <sys/sysinfo.h>

			int sysinfo(struct sysinfo *info);
			================================================================================
			$ info: 검색 결과를 리턴하는 sysinfo 구조체의 주소
			$ 성공: 0을 리턴, 오류: -1 리턴
		

<03> 프로세스 식별
	* PID(Process Id): 프로세스를 식별하기 위한 Id
	* Process Group: 관련 프로세스가 모여 프로세스 그룹을 구성

	(3.1) PID 검색
		- PID는 0부터 시작
			$ 0번 프로세스
				# sched(스케줄러: 프로세스에 CPU 시간을 할당하는 역할)
				# 커널의 일부분이라 별도의 실행 파일은 없다.

			$ 1번 프로세스
				# init

		- 기존 PID와 중복되지 않은 번호가 할당됨.
		- getpid()
			======================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getpid(void); // 이 함수를 호출한 프로세스의 PID를 리턴.
			======================================================================

		- 0번 프로세스를 제외한 모든 프로세스에는 자신을 생성한 프로세스가 존재(부모 프로세스).
		- ppid(Parent Process ID): 부모 프로세스의 PID

		- getppid()
			======================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getppid(void); // 부모 프로세스의 pid를 검색
			======================================================================

	(3.2) 프로세스 그룹
		- 관련 있는 프로세스를 묶은 것
		- PGID(Process Group ID)를 부여 받는다.
		- 프로세스는 프로세스 그룹을 구성하는 멤버가 된다.
		- BSD 계열 유닉스에서 작업(Job) 제어를 구현하면서 도입.

		- 프로세스 그룹 리더
			$ 그룹을 구성하는 프로세스 중 하나가 리더가 됨.
			$ 리더의 PID가 PGID가 된다.
			$ 리더는 변경될 수 있다.
			$ 리더 프로세스가 변경되면 PGID도 변경된다.

		- PGID 검색: getpgrp(2), getpgid(2)
			======================================================================
			#include <unistd.h>
			#include <sys/types.h>

			pid_t getpgrp(void); // 이 함수를 호출하는 프로세스가 속한 그룹의 PGID를 리턴.
			pid_t getpgid(pid_t pid); // pid 인자로 지정한 프로세스가 속한 그룹의 PGID를 리턴(0 이면 함수 호출한 프로세스의 PID를 리턴)
			======================================================================

		- pgid 변경: setpgid(2)
			======================================================================
			#include <sys/types.h>
			#include <unistd.h>

			int setpgid(pid_t pid, pid_t pgid); // pid가 가리키는 프로세스의 pgid를 지정 값으로 지정.
			======================================================================
			$ pgid: 새로 지정할 pgid
			$ pid와 pgid가 같으면 pid에 해당하는 프로세스가 그룹 리더가 된다.
			$ pid가 0이면 이 함수를 호출하는 현재 프로세스의 pid를 사용.
			$ pgid가 0이면 pid로 지정한 프로세스가 pgid가 된다.

	(3.3) 세션
		- POSIX 표준에서 제안한 개념
		- 사용자가 로그인해 작업하고 있는 터미널 단위로 프로세스 그룹을 묶은 것.
		- 관련 있는 프로세스 그룹을 모은 개념

			{그림}
			터미널
			------------------------------------------------------------------------
				세션
				------------------------------------------------------------
				|	프로세스 그룹 1				  프로세스 그룹 2					|
				|	------------------------  ----------------------------  |
				|	|	pid 1(세션 리더, PGID)| |		pid 10(세션 리더, PGID) | |
				|	|	pid 2				| |		pid 11			      | |
				|	|	pid 3				| |						      | |
				|	------------------------  ----------------------------- |
				------------------------------------------------------------
			------------------------------------------------------------------------

		- 세션 검색: getsid(2)
			$ 세션에도 ID가 할당됨.
			$ 프로세스가 새로운 세션을 생성하면 해당 프로세스는 세션 리더(Session Leader)가 된다.
				--> PID는 세션 ID가 된다.

			======================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t getsid(pid_t pid);
			======================================================================
			$ pid로 지정한 프로세스가 속한 세션의 ID를 리턴.
			$ pid가 0이면 현재 프로세스의 세션 ID를 리턴.

		- 세션 생성: setsid(2)
			$ 함수 사용으로 새로운 세션 만들 수 있다.
			$ 함수를 호출하는 프로세스가 프로세스 그룹 리더가 아니면 새로운 세션을 만들어 세션 리더가 되고 새로운 세션에서 프로세스 그룹 리더가 된다.
			$ setsid() 함수를 호출한 프로세스가 새로운 세션과 프로세스 그룹의 유일한 프로세스가 된다.

			======================================================================
			#include <sys/types.h>
			#include <unistd.h>

			pid_t setsid(void);
			======================================================================
			$ 호출 성공: 새로운 세션 ID를 리턴
			$ 오류: -1 리턴.

<04> 프로세스 실행 시간 측정
	- 프로세스 실행 시간은 times() 함수 사용해 측정 가능
		* 커널 모드에서 실행한 시간과 사용자 모드에서 실행한 시간을 구분해서 알려준다.

	(4.1) 프로세스 실행 시간의 구성
		- 프로세스 실행 시간: 시스템 실행 시간, 사용자 실행 시간(시스템 실행 시간 + 사용자 실행 시간)
			$ 시스템 실행 시간: 프로세스에서 커널의 코드를 수행한 시간(시스템 호출로 소비한 시간)
			$ 사용자 실행 시간: 사용자 모드에서 프로세스를 실행한 시간(함수나 반복문처럼 사용자가 작성한 코드를 실행하는 데 걸린 시간)

	(4.2) 프로세스 실행 시간 측정
		- 실행 시간 측정: times(2)
			======================================================================
			#include <sys/times.h>

			clock_t times(struct tms *buf);
			======================================================================
			$ buf: 실행 시간을 저장할 tms 구조체의 주소
			$ 시간 단위: clock ticks(시계의 클록 틱)
			$ 임의의 시점으로부터 경과된 클록 틱 수를 리턴, 오류: -1 리턴.

<05> 환경 변수의 활용
	- 프로세스가 실행되는 기본 환경
		$ 로그인명
		$ 로그인 셸
		$ 터미널에 설정된 언어
		$ 경로명 등
	- 모든 프로세스는 부모 프로세스에서 기본 환경을 물려받는다.

	(5.1) 환경 변수의 이해
		- '환경 변수명 = 값'
		- 환경 변수명: 관례적으로 대문자 사용

	(5.2) 환경 변수 사용
		- 전역 변수 사용: environ
			======================================================================
			#include <unistd.h>

			extern char **environ;
			======================================================================
			$ environ: 환경 변수 전체에 대한 포인터.(해당 변수를 사용해 환경 변수를 검색할 수 있다.)

		- main() 함수 인자 사용
			======================================================================
			#include <stdio.h>

			int main(int argc, char **argv, char **envp);
			======================================================================
			$ main 함수의 인자로 환경 변수를 활용할 때 특정 환경 변수의 값만 검색하는 일이 매우 불편하다.

		- 환경 변수 검색: getenv(3)
			======================================================================
			#include <stdlib.h>

			char *getenv(const char *name);
			======================================================================
			$ name: 환경 변수명
			$ 환경 변수가 설정되어 있는지 검색해 결괏값을 저장하고 주소를 리턴한다.
			$ 검색 실패시: 널 포인터를 리턴.

		- 환경 변수 설정: putenv(3)
			======================================================================
			#include <stdlib.h>

			int putenv(char *string);
			======================================================================
			$ string: 설정할 환경 변수와 값으로 구성한 문자열
			$ 프로그램에서 환경 변수를 설정할 수 있다.
			$ 기존의 환경 변숫값은 변경하고, 새로운 환경 변수는 malloc()으로 메모리를 할당해 추가한다.
			$ 수행 성공: 0 리턴.

			* 프로그램 안에서 변경한 환경 변수의 값이 부모 프로세스인 셸에서도 유효한 것은 아니다.

		- 환경 변수 설정: setenv(3)
			======================================================================
			#include <stdlib.h>

			int setenv(const char *name, const char *value, int overwrite);
			======================================================================
			$ name: 환경 변수명
			$ value: 환경 변숫값
			$ overwrite: 덮어쓰기
			$ overwrite: 0이면 덮어쓰기를 하지 않고, 0이 아니면 덮어쓰기를 한다.

			* putenv의 경우 putenv("TERM=vt100"); 형태로 인자를 지정하는 반면, setenv는 변숫값을 각각 인자로 지정한다.
				--> setenv("TERM", "vt100", 0);

		- 환경 변수 설정 삭제: unsetenv(3)
			======================================================================
			#include <stdlib.h>

			int unsetenv(const char *name);
			======================================================================
			$ name: 환경 변수명.
			$ name에 지정한 환경 변수를 삭제한다(해당 환경변수가 없으면 기존 환경을 변경하지 않음)


